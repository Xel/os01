x86 Assembly and C

In this chapter, we will explore assembly language, and how it
connects to C. But why should we do so? Isn't it better to trust
the compiler, plus no one writes assembly anymore?

Not quite. Surely, the compiler at its current state of the art
is trustworthy, and we do not need to write code in assembly,
most of the time. A compiler can generate code, but as mentioned
previously, a high-level language is a collection of patterns of
a lower-level language. It does not cover everything that a
hardware platform provides. As a consequence, not every assembly
instruction can be generated by a compiler, so we still need to
write assembly code for these circumstances to access
hardware-specific features. Since hardware-specific features
require writing assembly code, debugging requires reading it. We
might spend even more time reading than writing. Working with
low-level code that interacts directly with hardware, assembly
code is unavoidable. Also, understand how a compiler generates
assembly code could improve a programmer's productivity. For
example, if a job or school assignment requires us to write
assembly code, we can simply write it in C, then let gcc does the
hard working of writing the assembly code for us. We merely
collect the generated assembly code, modify as needed and be done
with the assignment.

We will learn objdump extensively, along with how to use Intel
documents to aid in understanding x86 assembly code.

  objdump

objdumpobjdump is a program that displays information about
object files. It will be handy later to debug incorrect layout
from manual linking. Now, we use objdump to examine how high
level source code maps to assembly code. For now, we ignore the
output and learn how to use the command first. It is simple to
use objdump :



$ objdump -d hello



-d option only displays assembled contents of executable
sections. A sectionsection is a block of memory that contains
either program code or data. A code section is executable by the
CPU, while a data section is not executable. Non-executable
sections, such as .data and .bss (for storing program data),
debug sections... are not displayed. We will learn more about
section when studying ELF binary file format in chapter [chap:The-Anatomy-of-a-program]
 . On the other hand:



$ objdump -D hello



where -D option displays assembly contents of all sections. If -D
, -d is implicitly assumed. objdump is mostly used for inspecting
assembly code, so -d is the most useful and thus is set by
default.

The output overruns the terminal screen. To make it easy for
reading, send all the output to less:



$ objdump -d hello | less



To intermix source code and assembly, the binary must be compiled
with -g option to include source code in it, then add -S option:



$ objdump -S hello | less



The default syntax used by objdump is AT&T syntax. To change it
to the familiar Intel syntax:



$ objdump -M intel -D hello | less



When using -M option, option -D or -d must be explicitly
supplied. Next, we will use objdump to examine how compiled C
data and code are represented in machine code.

Finally, we will write a 32-bit kernel, therefore we will need to
compile a 32-bit binary and examine it in 32-bit mode:



$ objdump -M i386,intel -D hello | less



-M i386 tells objdump to display assembly content using 32-bit
layout. Knowing the difference between 32-bit and 64-bit is
crucial for writing kernel code. We will examine this matter
later on when writing our kernel.

  Reading the output

At the start of the output displays the file format of the object
file:

hello: file format elf64-x86-64

After the line is a series of disassembled sections:

Disassembly of section .interp:

...

Disassembly of section .note.ABI-tag:

...

Disassembly of section .note.gnu.build-id:

...

...

etc

Finally, each disassembled section displays its actual content -
which is a sequence of assembly instructions - with the following
format:

4004d6:       55                      push   rbp

• The first column is the address of an assembly instruction. In
  the above example, the address is 0x4004d6.

• The second column is assembly instruction in raw hex values. In
  the above example, the address is 0x55.

• The third column is the assembly instruction. Depends on the
  section, the assembly instruction might be meaningful or
  meaningless. For example, if the assembly instructions are in a
  .text section, then the assembly instructions are actual
  program code. On the other hand, if the assembly instructions
  are displayed in a .data section, then we can safely ignore the
  displayed instructions. The reason is that objdump doesn't know
  which hex values are code and which are data, so it blindly
  translates every hex values into assembly instructions. In the
  above example, the assembly instruction is push %rb.

• The optional fourth column is a comment - appears when there is
  a reference to an address - to inform where the address
  originates. For example, the comment in blue:

      lea    r12,[rip+0x2008ee]        # 600e10
  <__frame_dummy_init_array_entry>

  is to inform that the referenced address from [rip+0x2008ee] is
  0x600e10, where the variable __frame_dummy_init_array_entry
  resides.

In a disassembled section, it may also contain labels. A label is
a name given to an assembly instruction. The label denotes the
purpose of an assembly block to a human reader, to make it easier
to understand. For example, .text section carries many of such
labels to denote where code in a program start; .text section
below carries two functions: _start and deregister_tm_clones. The
_start function starts at address 4003e0, is annotated to the
left of the function name. Right below _start label is also the
instruction at address 4003e0. This whole thing means that a
label is simply a name of a memory address. The function
deregister_tm_clones also shares the same format as every
function in the section.

00000000004003e0 <_start>:

  4003e0:       31 ed                   xor    ebp,ebp

  4003e2:       49 89 d1                mov    r9,rdx

  4003e5:       5e                      pop    rsi

...more assembly code....



0000000000400410 <deregister_tm_clones>:

  400410:       b8 3f 10 60 00          mov    eax,0x60103f

  400415:       55                      push   rbp

  400416:       48 2d 38 10 60 00       sub    rax,0x601038

...more assembly code....

  Intel manuals

The best way to understand and use assembly language properly is
to understand precisely the underlying computer architecture and
what each machine instruction does. To do so, the most reliable
source is to refer to documents provided by vendors. After all,
hardware vendors are the one who made their machines. To
understand Intel's instruction set, we need the document “Intel
64 and IA-32 architectures software developer's manual combined
volumes 2A, 2B, 2C, and 2D: Instruction set reference, A-Z”. The
document can be retrieved here: https://software.intel.com/en-us/articles/intel-sdm
.

• Chapter 1 provides brief information about the manual, and the
  comment notations used in the book.

• Chapter 2 provides an in-depth explanation of the anatomy of an
  assembly instruction, which we will investigate in the next
  section.

• Chapter 3 - 5 provide the details of every instruction of the
  x86_64 architecture.

• Chapter 6 provides information about safer mode extensions. We
  won't need to use this chapter.

The first volume “Intel® 64 and IA-32 Architectures Software
Developer’s Manual Volume 1: Basic Architecture” describes the
basic architecture and programming environment of Intel
processors. In the book, Chapter 5 gives the summary of all Intel
instructions, by listing instructions into different categories.
We only need to learn general-purpose instructions listed chapter
5.1 for our OS. Chapter 7 describes the purpose of each category.
Gradually, we will learn all of these instructions.

Read section 1.3 in volume 2, exclude sections 1.3.5 and 1.3.7.

  Experiment with assembly code

The subsequent sections examine the anatomy of an assembly
instruction. To fully understand, it is necessary to write code
and see the code in its actual form displayed as hex numbers. For
this purpose, we use nasm assembler to write a few line of
assembly code and see the generated code.


-------------------------------------------


Suppose we want to see the machine code generated for this
instruction:

  jmp eax

  Then, we use an editor e.g. Emacs, then create a new file,
  write the code and save it in a file, e.g. test.asm. Then, in
  the terminal, run the command:



  $ nasm -f bin test.asm -o test



  -f option specifies the file format, e.g. ELF, of the final
  output file. But in this case, the format is bin, which means
  this file is just a flat binary output without any extra
  information. That is, the written assembly code is translated
  to machine code as is, without the overhead of the metadata
  from file format like ELF. Indeed, after compiling, we can
  examine the output using this command:



  $ hd test



  hd (short for hexdump) is a program that displays the content
  of a file in hex format[margin:
Though its name is short for hexdump, hd can display in different
base, e.g. binary, other than hex.
]. And get the following output:

  00000000  66 ff e0                          |f..|

  00000003

  The file only consists of 3 bytes: 66 ff e0, which is
  equivalent to the instruction jmp eax.


-------------------------------------------




If we were to use elf as file format:



  $ nasm -f elf test.asm -o test



  It would be more challenging to learn and understand assembly
  instructions with all the added noise[footnote:
The output from hd.
]:

  00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00
  |.ELF............|

  00000010  01 00 03 00 01 00 00 00  00 00 00 00 00 00 00 00
  |................|

  00000020  40 00 00 00 00 00 00 00  34 00 00 00 00 00 28 00
  |@.......4.....(.|

  00000030  05 00 02 00 00 00 00 00  00 00 00 00 00 00 00 00
  |................|

  00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  |................|

  *

  00000060  00 00 00 00 00 00 00 00  01 00 00 00 01 00 00 00
  |................|

  00000070  06 00 00 00 00 00 00 00  10 01 00 00 02 00 00 00
  |................|

  00000080  00 00 00 00 00 00 00 00  10 00 00 00 00 00 00 00
  |................|

  00000090  07 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00
  |................|

  000000a0  20 01 00 00 21 00 00 00  00 00 00 00 00 00 00 00  |
  ...!...........|

  000000b0  01 00 00 00 00 00 00 00  11 00 00 00 02 00 00 00
  |................|

  000000c0  00 00 00 00 00 00 00 00  50 01 00 00 30 00 00 00
  |........P...0...|

  000000d0  04 00 00 00 03 00 00 00  04 00 00 00 10 00 00 00
  |................|

  000000e0  19 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00
  |................|

  000000f0  80 01 00 00 0d 00 00 00  00 00 00 00 00 00 00 00
  |................|

  00000100  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  |................|

  00000110  ff e0 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  |................|

  00000120  00 2e 74 65 78 74 00 2e  73 68 73 74 72 74 61 62
  |..text..shstrtab|

  00000130  00 2e 73 79 6d 74 61 62  00 2e 73 74 72 74 61 62
  |..symtab..strtab|

  00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  |................|

  *

  00000160  01 00 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff
  |................|

  00000170  00 00 00 00 00 00 00 00  00 00 00 00 03 00 01 00
  |................|

  00000180  00 64 69 73 70 38 2d 35  2e 61 73 6d 00 00 00 00
  |.disp8-5.asm....|

  00000190

  Thus, it is better just to use flat binary format in this case,
  to experiment instruction by instruction.

With such a simple workflow, we are ready to investigate the
structure of every assembly instruction.

Note: Using the bin format puts nasm by default into 16-bit mode.
To enable 32-bit code to be generated, we must add this line at
the beginning of an nasm source file:

bits 32

  Anatomy of an Assembly Instruction

Chapter 2 of the instruction reference manual provides an
in-depth of view of instruction format. But, the information is
too much that it can overwhelm beginners. This section provides
an easier instruction before reading the actual chapter in the
manual.





<Graphics file: C:/Users/Tu Do/os01/book_src/images/04/x86_instruction_format.pdf>



Recall that an assembly instruction is simply a fixed-size series
of bits. The length of an instruction varies and depends on how
complicated an instruction is. What every instruction shares is a
common format described in the figure above that divides the bits
of an instruction into smaller parts that encode different types
of information. These parts are:

  Instruction Prefixes appears at the beginning of an
  instruction. Prefixes are optional. A programmer can choose to
  use a prefix or not because in practice, a so-called prefix is
  just another assembly instruction to be inserted before another
  assembly instruction that such prefix is applicable.
  Instructions with 2 or 3-bytes opcodes include the prefixes by
  default.

  Opcode is a unique number that identifies an instruction. Each
  opcode is given an mnemonic name that is human readable, e.g.
  one of the opcodes for instruction add is 04. When a CPU sees
  the number 04 in its instruction cache, it sees instruction add
  and execute accordingly. Opcode can be 1,2 or 3 bytes long and
  includes an additional 3-bit field in the ModR/M byte when
  needed.

  This instruction:

  jmp [0x1234]

  generates the machine code:

  ff 26 34 12

  The very first byte, 0xff is the opcode, which is unique to jmp
  instruction.

  ModR/M specifies operands of an instruction. Operand can either
  be a register, a memory location or an immediate value. This
  component of an instruction consists of 3 smaller parts:

  • mod field, or modifier field, is combined with r/m field for
    a total of 5 bits of information to encode 32 possible
    values: 8 registers and 24 addressing modes.

  • reg/opcode field encodes either a register operand, or
    extends the Opcode field with 3 more bits.

  • r/m field encodes either a register operand or can be
    combined with mod field to encode an addressing mode.

  The tables [mod-rm-16] and [mod-rm-32] list all possible 256
  values of ModR/M byte and how each value maps to an addressing
  mode and a register, in 16-bit and 32-bit modes.






+---------------------------------------------+-------+-------+-------+-------+-------+-------+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| r8(/r)                                      | AL    | CL    | DL    | BL    | AH    | CH    | DH    | BH                                                                                                                                                                                                                                                                                                                                      |
| r16(/r)                                     | AX    | CX    | DX    | BX    | SP    | BP¹   | SI    | DI                                                                                                                                                                                                                                                                                                                                      |
| r32(/r)                                     | EAX   | ECX   | EDX   | EBX   | ESP   | EBP   | ESI   | EDI                                                                                                                                                                                                                                                                                                                                     |
| mm(/r)                                      | MM0   | MM1   | MM2   | MM3   | MM4   | MM5   | MM6   | MM7                                                                                                                                                                                                                                                                                                                                     |
| xmm(/r)                                     | XMM0  | XMM1  | XMM2  | XMM3  | XMM4  | XMM5  | XMM6  | XMM7                                                                                                                                                                                                                                                                                                                                    |
| (In decimal) /digit (Opcode)                | 0     | 1     | 2     | 3     | 4     | 5     | 6     | 7                                                                                                                                                                                                                                                                                                                                       |
| (In binary) REG =                           | 000   | 001   | 010   | 011   | 100   | 101   | 110   | 111                                                                                                                                                                                                                                                                                                                                     |
+---------------------------+--------+--------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|        Effective Address  |   Mod  |   R/M  |                                                                                                                                                                             Values of ModR/M Byte (In Hexadecimal)                                                                                                                                                                              |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [BX + SI]                 | 00     | 000    | 00    | 08    | 10    | 18    | 20    | 28    | 30    | 38                                                                                                                                                                                                                                                                                                                                      |
| [BX + DI]                 |        | 001    | 01    | 09    | 11    | 19    | 21    | 29    | 31    | 39                                                                                                                                                                                                                                                                                                                                      |
| [BP + SI]                 |        | 010    | 02    | 0A    | 12    | 1A    | 22    | 2A    | 32    | 3A                                                                                                                                                                                                                                                                                                                                      |
| [BP + DI]                 |        | 011    | 03    | 0B    | 13    | 1B    | 23    | 2B    | 33    | 3B                                                                                                                                                                                                                                                                                                                                      |
| [SI]                      |        | 100    | 04    | 0C    | 14    | 1C    | 24    | 2C    | 34    | 3C                                                                                                                                                                                                                                                                                                                                      |
| [DI]                      |        | 101    | 05    | 0D    | 15    | 1D    | 25    | 2D    | 35    | 3D                                                                                                                                                                                                                                                                                                                                      |
| disp16²                   |        | 110    | 06    | 0E    | 16    | 1E    | 26    | 2E    | 36    | 3E                                                                                                                                                                                                                                                                                                                                      |
| [BX]                      |        | 111    | 07    | 0F    | 17    | 1F    | 27    | 2F    | 37    | 3F                                                                                                                                                                                                                                                                                                                                      |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [BX + SI] + disp8³        | 01     | 000    | 40    | 48    | 50    | 58    | 60    | 68    | 70    | 78                                                                                                                                                                                                                                                                                                                                      |
| [BX + DI] + disp8         |        | 001    | 41    | 49    | 51    | 59    | 61    | 69    | 71    | 79                                                                                                                                                                                                                                                                                                                                      |
| [BP + SI] + disp8         |        | 010    | 42    | 4A    | 52    | 5A    | 62    | 6A    | 72    | 7A                                                                                                                                                                                                                                                                                                                                      |
| [BP + DI] + disp8         |        | 011    | 43    | 4B    | 53    | 5B    | 63    | 6B    | 73    | 7B                                                                                                                                                                                                                                                                                                                                      |
| [SI] + disp8              |        | 100    | 44    | 4C    | 54    | 5C    | 64    | 6C    | 74    | 7C                                                                                                                                                                                                                                                                                                                                      |
| [DI] + disp8              |        | 101    | 45    | 4D    | 55    | 5D    | 65    | 6D    | 75    | 7D                                                                                                                                                                                                                                                                                                                                      |
| [BP] + disp8              |        | 110    | 46    | 4E    | 56    | 5E    | 66    | 6E    | 76    | 7E                                                                                                                                                                                                                                                                                                                                      |
| [BX] + disp8              |        | 111    | 47    | 4F    | 57    | 5F    | 67    | 6F    | 77    | 7F                                                                                                                                                                                                                                                                                                                                      |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [BX + SI] + disp16        | 10     | 000    | 80    | 88    | 90    | 98    | A0    | A8    | B0    | B8                                                                                                                                                                                                                                                                                                                                      |
| [BX + DI] + disp16        |        | 001    | 81    | 89    | 91    | 99    | A1    | A9    | B1    | B9                                                                                                                                                                                                                                                                                                                                      |
| [BP + SI] + disp16        |        | 010    | 82    | 8A    | 92    | 9A    | A2    | AA    | B2    | BA                                                                                                                                                                                                                                                                                                                                      |
| [BP + DI] + disp16        |        | 011    | 83    | 8B    | 93    | 9B    | A3    | AB    | B3    | BB                                                                                                                                                                                                                                                                                                                                      |
| [SI] + disp16             |        | 100    | 84    | 8C    | 94    | 9C    | A4    | AC    | B4    | BC                                                                                                                                                                                                                                                                                                                                      |
| [DI] + disp16             |        | 101    | 85    | 8D    | 95    | 9D    | A5    | AD    | B5    | BD                                                                                                                                                                                                                                                                                                                                      |
| [BP] + disp16             |        | 110    | 86    | 8E    | 96    | 9E    | A6    | AE    | B6    | BE                                                                                                                                                                                                                                                                                                                                      |
| [BX] + disp16             |        | 111    | 87    | 8F    | 97    | 9F    | A7    | AF    | B7    | BF                                                                                                                                                                                                                                                                                                                                      |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EAX/AX/AL/MM0/XMM0        | 11     | 000    | C0    | C8    | D0    | D8    | E0    | E8    | F0    | F8                                                                                                                                                                                                                                                                                                                                      |
| ECX/CX/CL/MM1/XMM1        |        | 001    | C1    | C9    | D1    | D9    | E1    | E9    | F1    | F9                                                                                                                                                                                                                                                                                                                                      |
| EDX/DX/DL/MM2/XMM2        |        | 010    | C2    | CA    | D2    | DA    | E2    | EA    | F2    | FA                                                                                                                                                                                                                                                                                                                                      |
| EBX/BX/BL/MM3/XMM3        |        | 011    | C3    | CB    | D3    | DB    | E3    | EB    | F3    | FB                                                                                                                                                                                                                                                                                                                                      |
| ESP/SP/AHMM4/XMM4         |        | 100    | C4    | CC    | D4    | DC    | E4    | EC    | F4    | FC                                                                                                                                                                                                                                                                                                                                      |
| EBP/BP/CH/MM5/XMM5        |        | 101    | C5    | CD    | D5    | DD    | E5    | ED    | F5    | FD                                                                                                                                                                                                                                                                                                                                      |
| ESI/SI/DH/MM6/XMM6        |        | 110    | C6    | CE    | D6    | DE    | E6    | EE    | F6    | FE                                                                                                                                                                                                                                                                                                                                      |
| EDI/DI/BH/MM7/XMM7        |        | 111    | C7    | CF    | D7    | DF    | E7    | EF    | F7    | FF                                                                                                                                                                                                                                                                                                                                      |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1. The default segment register is SS for the effective addresses
  containing a BP index, DS for other effective addresses.

2. The disp16 nomenclature denotes a 16-bit displacement that
  follows the ModR/M byte and that is added to the index.

3. The disp8 nomenclature denotes an 8-bit displacement that
  follows the ModR/M byte and that is sign-extended and added to
  the index.
<mod-rm-16>






+---------------------------------------------+-------+-------+-------+-------+-------+-------+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| r8(/r)                                      | AL    | CL    | DL    | BL    | AH    | CH    | DH    | BH                                                                                                                                                                                                                                                                                                                                                   |
| r16(/r)                                     | AX    | CX    | DX    | BX    | SP    | BP    | SI    | DI                                                                                                                                                                                                                                                                                                                                                   |
| r32(/r)                                     | EAX   | ECX   | EDX   | EBX   | ESP   | EBP   | ESI   | EDI                                                                                                                                                                                                                                                                                                                                                  |
| mm(/r)                                      | MM0   | MM1   | MM2   | MM3   | MM4   | MM5   | MM6   | MM7                                                                                                                                                                                                                                                                                                                                                  |
| xmm(/r)                                     | XMM0  | XMM1  | XMM2  | XMM3  | XMM4  | XMM5  | XMM6  | XMM7                                                                                                                                                                                                                                                                                                                                                 |
| (In decimal) /digit (Opcode)                | 0     | 1     | 2     | 3     | 4     | 5     | 6     | 7                                                                                                                                                                                                                                                                                                                                                    |
| (In binary) REG =                           | 000   | 001   | 010   | 011   | 100   | 101   | 110   | 111                                                                                                                                                                                                                                                                                                                                                  |
+---------------------------+--------+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|        Effective Address  |   Mod  |   R/M  |                                                                                                                                                                                    Values of ModR/M Byte (In Hexadecimal)                                                                                                                                                                                    |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [EAX]                     | 00     | 000    | 00    | 08    | 10    | 18    | 20    | 28    | 30    | 38                                                                                                                                                                                                                                                                                                                                                   |
| [ECX]                     |        | 001    | 01    | 09    | 11    | 19    | 21    | 29    | 31    | 39                                                                                                                                                                                                                                                                                                                                                   |
| [EDX]                     |        | 010    | 02    | 0A    | 12    | 1A    | 22    | 2A    | 32    | 3A                                                                                                                                                                                                                                                                                                                                                   |
| [EBX]                     |        | 011    | 03    | 0B    | 13    | 1B    | 23    | 2B    | 33    | 3B                                                                                                                                                                                                                                                                                                                                                   |
| [-][-]¹                   |        | 100    | 04    | 0C    | 14    | 1C    | 24    | 2C    | 34    | 3C                                                                                                                                                                                                                                                                                                                                                   |
| disp32²                   |        | 101    | 05    | 0D    | 15    | 1D    | 25    | 2D    | 35    | 3D                                                                                                                                                                                                                                                                                                                                                   |
| [ESI]                     |        | 110    | 06    | 0E    | 16    | 1E    | 26    | 2E    | 36    | 3E                                                                                                                                                                                                                                                                                                                                                   |
| [EDI]                     |        | 111    | 07    | 0F    | 17    | 1F    | 27    | 2F    | 37    | 3F                                                                                                                                                                                                                                                                                                                                                   |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [EAX] + disp8³            | 01     | 000    | 40    | 48    | 50    | 58    | 60    | 68    | 70    | 78                                                                                                                                                                                                                                                                                                                                                   |
| [ECX] + disp8             |        | 001    | 41    | 49    | 51    | 59    | 61    | 69    | 71    | 79                                                                                                                                                                                                                                                                                                                                                   |
| [EDX] + disp8             |        | 010    | 42    | 4A    | 52    | 5A    | 62    | 6A    | 72    | 7A                                                                                                                                                                                                                                                                                                                                                   |
| [EBX] + disp8             |        | 011    | 43    | 4B    | 53    | 5B    | 63    | 6B    | 73    | 7B                                                                                                                                                                                                                                                                                                                                                   |
| [-][-] + disp8            |        | 100    | 44    | 4C    | 54    | 5C    | 64    | 6C    | 74    | 7C                                                                                                                                                                                                                                                                                                                                                   |
| [EBP] + disp8             |        | 101    | 45    | 4D    | 55    | 5D    | 65    | 6D    | 75    | 7D                                                                                                                                                                                                                                                                                                                                                   |
| [ESI] + disp8             |        | 110    | 46    | 4E    | 56    | 5E    | 66    | 6E    | 76    | 7E                                                                                                                                                                                                                                                                                                                                                   |
| [EDI] + disp8             |        | 111    | 47    | 4F    | 57    | 5F    | 67    | 6F    | 77    | 7F                                                                                                                                                                                                                                                                                                                                                   |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [EAX] + disp32            | 10     | 000    | 80    | 88    | 90    | 98    | A0    | A8    | B0    | B8                                                                                                                                                                                                                                                                                                                                                   |
| [ECX] + disp32            |        | 001    | 81    | 89    | 91    | 99    | A1    | A9    | B1    | B9                                                                                                                                                                                                                                                                                                                                                   |
| [EDX] + disp32            |        | 010    | 82    | 8A    | 92    | 9A    | A2    | AA    | B2    | BA                                                                                                                                                                                                                                                                                                                                                   |
| [EBX] + disp32            |        | 011    | 83    | 8B    | 93    | 9B    | A3    | AB    | B3    | BB                                                                                                                                                                                                                                                                                                                                                   |
| [-][-] + disp32           |        | 100    | 84    | 8C    | 94    | 9C    | A4    | AC    | B4    | BC                                                                                                                                                                                                                                                                                                                                                   |
| [EBP] + disp32            |        | 101    | 85    | 8D    | 95    | 9D    | A5    | AD    | B5    | BD                                                                                                                                                                                                                                                                                                                                                   |
| [ESI] + disp32            |        | 110    | 86    | 8E    | 96    | 9E    | A6    | AE    | B6    | BE                                                                                                                                                                                                                                                                                                                                                   |
| [EDI] + disp32            |        | 111    | 87    | 8F    | 97    | 9F    | A7    | AF    | B7    | BF                                                                                                                                                                                                                                                                                                                                                   |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EAX/AX/AL/MM0/XMM0        | 11     | 000    | C0    | C8    | D0    | D8    | E0    | E8    | F0    | F8                                                                                                                                                                                                                                                                                                                                                   |
| ECX/CX/CL/MM/XMM1         |        | 001    | C1    | C9    | D1    | D9    | E1    | E9    | F1    | F9                                                                                                                                                                                                                                                                                                                                                   |
| EDX/DX/DL/MM2/XMM2        |        | 010    | C2    | CA    | D2    | DA    | E2    | EA    | F2    | FA                                                                                                                                                                                                                                                                                                                                                   |
| EBX/BX/BL/MM3/XMM3        |        | 011    | C3    | CB    | D3    | DB    | E3    | EB    | F3    | FB                                                                                                                                                                                                                                                                                                                                                   |
| ESP/SP/AH/MM4/XMM4        |        | 100    | C4    | CC    | D4    | DC    | E4    | EC    | F4    | FC                                                                                                                                                                                                                                                                                                                                                   |
| EBP/BP/CH/MM5/XMM5        |        | 101    | C5    | CD    | D5    | DD    | E5    | ED    | F5    | FD                                                                                                                                                                                                                                                                                                                                                   |
| ESI/SI/DH/MM6/XMM6        |        | 110    | C6    | CE    | D6    | DE    | E6    | EE    | F6    | FE                                                                                                                                                                                                                                                                                                                                                   |
| EDI/DI/BH/MM7/XMM7        |        | 111    | C7    | CF    | D7    | DF    | E7    | EF    | F7    | FF                                                                                                                                                                                                                                                                                                                                                   |
+---------------------------+--------+--------+-------+-------+-------+-------+-------+-------+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1. The [-][-] nomenclature means a SIB follows the ModR/M byte.

2. The disp32 nomenclature denotes a 32-bit displacement that
  follows the ModR/M byte (or the SIB byte if one is present) and
  that is added to the index.

3. The disp8 nomenclature denotes an 8-bit displacement that
  follows the ModR/M byte (or the SIB byte if one is present) and
  that is sign-extended and added to the index.
<mod-rm-32>










How to read the table:

In an instruction, next to the opcode is a ModR/M byte. Then,
look up the byte value in this table to get the corresponding
operands in the row and column.


-------------------------------------------


An instruction uses this addressing mode:

  jmp [0x1234]

  Then, the machine code is:

  ff 26 34 12

  0xff is the opcode. Next to it, 0x26 is the ModR/M byte. Look
  up in the 16-bit table [margin:
Remember, using bin format generates 16-bit code by default
], the first operand is in the row, equivalent to a disp16, which
  means a 16-bit offset. Since the instruction does not have a
  second operand, the column can be ignored.

  An instruction uses this addressing mode:

  add eax, ecx

  Then the machine code is:

  01 c8

  0x01 is the opcode. Next to it, c8 is the ModR/M byte. Look up
  in the 16-bit table at c8 value, the row tells the first
  operand is ax [margin:
Remember, using bin format generates 16-bit code by default
], the column tells the second operand is cx; the column can't be
  ignored as the second operand is in the instruction.

  Why is the first operand in the row and the second in a column?
  Let's break down the ModR/M byte, with an example value c8,
  into bits:


+----------+---------------------+-------------+
  |   mod    |     reg/opcode      |     r/m     |
  +----------+---------------------+-------------+
  +----+-----+----+----+-----------+----+----+---+
  | 1  | 1   | 0  | 0  |    1      | 0  | 0  | 0 |
  +----+-----+----+----+-----------+----+----+---+


  The mod field divides addressing modes into 4 different
  categories. Further combines with the r/m field, exactly one
  addressing mode can be selected from one of the 24 rows. If an
  instruction only requires one operand, then the column can be
  ignored. Then the reg/opcode field finally provides the if an
  instruction requires one.


-------------------------------------------


  SIB is Scale-Index-Base byte. This byte encodes ways to
  calculate the memory position into an element of an array. SIB
  is the name that is based on this formula for calculating an
  effective address:

  \mathtt{Effective\,address=scale*index+base}


  • Index is an offset into an array.

  • Scale is a factor of Index. Scale is one of the values 1, 2,
    4 or 8; any other value is invalid. To scale with values
    other than 2, 4 or 8, the scale factor must be set to 1, and
    the offset must be calculated manually. For example, if we
    want to get the address of the n[superscript:th] element in an array and each element is 12-bytes long. Because
    each element is 12-bytes long instead of 1, 2, 4 or 8, Scale
    is set to 1 and a compiler needs to calculate the offset:

    \mathtt{Effective\,address=1*(12*n)+base}


    Why do we bother with SIB when we can manually calculate the
    offset? The answer is that in the above scenario, an
    additional mul instruction must be executed to get the
    offset, and the mul instruction consumes more than 1 byte,
    while the SIB only consumes 1 byte. More importantly, if the
    element is repeated accessed many times in a loop, e.g.
    millions of times, then an extra mul instruction can
    detriment the performance as the CPU must spend time
    executing millions of these additional mul instructions.

    The values 2, 4 and 8 are not random chosen. They map to
    16-bit (or 2 bytes), 32-bit (or 4 bytes) and 64-bit (or 8
    bytes) numbers that are often used for intensive numeric
    calculations.

  • Base is the starting address.

  Below is the table listing all 256 values of SIB byte, with the
  lookup rule similar to ModR/M tables:




+--------------------------------------------+------+------+-------+-------+------+------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | r32(/r)                                    | EAX  | ECX  | EDX   | EBX   | ESP  | EBP  | ESI  | EDI                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
  | (In decimal) /digit (Opcode)               | 0    | 1    | 2     | 3     | 4    | 5    | 6    | 7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
  | (In binary) REG =                          | 000  | 001  | 010   | 011   | 100  | 101  | 110  | 111                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
  +---------------------------+-------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |        Effective Address  |   SS  |   R/M  |                                                                                                                                                                                                                                                                                                                 Values of SIB Byte (In Hexadecimal)                                                                                                                                                                                                                                                                                                                 |
  +---------------------------+-------+--------+------+------+-------+-------+------+------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | [EAX]                     | 00    | 000    | 00   | 01   | 02    | 03    | 04   | 05   | 06   | 07                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ECX]                     |       | 001    | 08   | 09   | 0A    | 0B    | 0C   | 0D   | 0E   | 0F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDX]                     |       | 010    | 10   | 11   | 12    | 13    | 14   | 15   | 16   | 17                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBX]                     |       | 011    | 18   | 19   | 1A    | 1B    | 1C   | 1D   | 1E   | 1F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | none                      |       | 100    | 20   | 21   | 22    | 23    | 24   | 25   | 26   | 27                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBP]                     |       | 101    | 28   | 29   | 2A    | 2B    | 2C   | 2D   | 2E   | 2F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ESI]                     |       | 110    | 30   | 31   | 32    | 33    | 34   | 35   | 36   | 37                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDI]                     |       | 111    | 38   | 39   | 3A    | 3B    | 3C   | 3D   | 3E   | 3F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  +---------------------------+-------+--------+------+------+-------+-------+------+------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | [EAX*2]                   | 01    | 000    | 40   | 41   | 42    | 43    | 44   | 45   | 46   | 47                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ECX*2]                   |       | 001    | 48   | 49   | 4A    | 4B    | 4C   | 4D   | 4E   | 4F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDX*2]                   |       | 010    | 50   | 51   | 52    | 53    | 54   | 55   | 56   | 57                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBX*2]                   |       | 011    | 58   | 59   | 5A    | 5B    | 5C   | 5D   | 5E   | 5F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | none                      |       | 100    | 60   | 61   | 62    | 63    | 64   | 65   | 66   | 67                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBP*2]                   |       | 101    | 68   | 69   | 6A    | 6B    | 6C   | 6D   | 6E   | 6F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ESI*2]                   |       | 110    | 70   | 71   | 72    | 73    | 74   | 75   | 76   | 77                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDI*2]                   |       | 111    | 78   | 79   | 7A    | 7B    | 7C   | 7D   | 7E   | 7F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  +---------------------------+-------+--------+------+------+-------+-------+------+------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | [EAX*4]                   | 10    | 000    | 80   | 81   | 82    | 83    | 84   | 85   | 86   | 87                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ECX*4]                   |       | 001    | 88   | 89   | 8A    | 8B    | 8C   | 8D   | 8E   | 8F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDX*4]                   |       | 010    | 90   | 91   | 92    | 93    | 94   | 95   | 96   | 97                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBX*4]                   |       | 011    | 98   | 99   | 9A    | 9B    | 9C   | 9D   | 9E   | 9F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | none                      |       | 100    | A0   | A1   | A2    | A3    | A4   | A5   | A6   | A7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBP*4]                   |       | 101    | A8   | A9   | AA    | AB    | AC   | AD   | AE   | AF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ESI*4]                   |       | 110    | B0   | B1   | B2    | B3    | B4   | B5   | B6   | B7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDI*4]                   |       | 111    | B8   | B9   | BA    | BB    | BC   | BD   | BE   | BF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  +---------------------------+-------+--------+------+------+-------+-------+------+------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | [EAX*8]                   | 11    | 000    | C0   | C1   | C2    | C3    | C4   | C5   | C6   | C7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ECX*8]                   |       | 001    | C8   | C9   | CA    | CB    | CC   | CD   | CE   | CF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDX*8]                   |       | 010    | D0   | D1   | D2    | D3    | D4   | D5   | D6   | D7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBX*8]                   |       | 011    | D8   | D9   | DA    | DB    | DC   | DD   | DE   | DF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | none                      |       | 100    | E0   | E1   | E2    | E3    | E4   | E5   | E6   | E7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EBP*8]                   |       | 101    | E8   | E9   | EA    | EB    | EC   | ED   | EE   | EF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [ESI*8]                   |       | 110    | F0   | F1   | F2    | F3    | F4   | F5   | F6   | F7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  | [EDI*8]                   |       | 111    | F8   | F9   | FA    | FB    | FC   | FD   | FE   | FF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
  +---------------------------+-------+--------+------+------+-------+-------+------+------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    1. The [*] nomenclature means a disp32 with no base if the MOD is
  00B. Otherwise, [*] means disp8 or disp32 + [EBP]. This
  provides the following address modes:


+-----------+---------------------------------+
| MOD bits  | Effective Address               |
+-----------+---------------------------------+
+-----------+---------------------------------+
| 00        | [scaled index] + disp32         |
+-----------+---------------------------------+
| 01        | [scaled index] + disp8 + [EBP]  |
+-----------+---------------------------------+
| 10        | [scaled index] + disp32 + [EBP] |
+-----------+---------------------------------+

  <sib>



  This instruction:

    jmp [eax*2 + ebx]

    generates the following code:

    00000000  67 ff 24 43

    First of all, the first byte, 0x67 is not an opcode but a
    prefix. The number is a predefined prefix for address-size
    override prefix. After the prefix, comes the opcode 0xff and
    the ModR/M byte 0x24. The value from ModR/M suggests that
    there exists a SIB byte that follows. The SIB byte is 0x43.

    Look up in the SIB table, the row tells that eax is scaled by
    2, and the column tells that the base to be added is in ebx.

  Displacement is the offset from the start of the base index.

  This instruction:

    jmp [0x1234]

    generates machine code is:

    ff 26 34 12

    0x1234, which is generated as 34 12 in raw machine code, is
    the displacement and stands right next to 0x26, which is the
    ModR/M byte.

    This instruction:

      jmp [eax * 4  + 0x1234]

    generates the machine code:

    67 ff 24 8d 34 12 00 00

    • 0x67 is an address-size override prefix. Its meaning is
      that if an instruction runs a default address size e.g.
      16-bit, the use of prefix enables the instruction to use
      non-default address size, e.g. 32-bit or 64-bit. Since the
      binary is supposed to be 16-bit, 0x67 changes the
      instruction to 32-bit mode.

    • 0xff is the opcode.

    • 0x24 is the ModR/M byte. The value suggests that a SIB byte
      follows, according to table [mod-rm-32].

    • 34 12 00 00 is the displacement. As can be seen, the
      displacement is 4 bytes in size, which is equivalent to
      32-bit, due to address-size override prefix.

  Immediate When an instruction accepts a fixed value, e.g.
  0x1234, as an operand, this optional field holds the value.
  Note that this field is different from displacement: the value
  is not necessary used an offset, but an arbitrary value of
  anything.

  This instruction:

    mov eax, 0x1234

    generates the code:

    66 b8 34 12 00 00

    • 0x66 is operand-sized override prefix. Similar to
      address-size override prefix, this prefix enables
      operand-size to be non-default.

    • 0xb8 is one of the opcodes for mov instruction.

    • 0x1234 is the value to be stored in register eax. It is
      just a value for storing directly into a register, and
      nothing more. On the other hand, displacement value is an
      offset for some address calculation.

Read section 2.1 in Volume 2 for even more details.

  Skim through section 5.1 in volume 1. Read chapter 7 in volume
  1. If there are terminologies that you don't understand e.g.
  segmentation, don't worry as the terms will be explained in
  later chapters or ignored.

  Understand an instruction in detail

In the instruction reference manual (Volume 2), from chapter 3
onward, every x86 instruction is documented in detail. Whenever
the precise behavior of an instruction is needed, we always
consult this document first. However, before using the document,
we must know the writing conventions first. Every instruction has
the following common structure for organizing information:

  Opcode table lists all possible opcodes of an assembly
  instruction.

  Each table contains the following fields, and can have one or
  more rows:


+---------------------------------------------------------------------------------------+
  | Opcode    Instruction    Op/En    64/32-bit Mode    CPUID
Feature flag    Description |
  +---------------------------------------------------------------------------------------+


  Opcode shows a unique hexadecimal number assigned to an
    instruction. There can be more than one opcode for an
    instruction, each encodes a variant of the instruction. For
    example, one variant requires one operand, but another
    requires two. In this column, there can be other notations
    aside from hexadecimal numbers. For example, /r indicates
    that the ModR/M byte of the instruction contains a reg
    operand and an r/m operand. The detail listing is in section
    3.1.1.1 and 3.1.1.2 in the Intel's manual, volume 2.

  Instruction gives the syntax of the assembly instruction that a
    programmer can use for writing code. Aside from the mnemonic
    representation of the opcode, e.g. jmp, other symbols
    represent operands with specific properties in the
    instruction. For example, rel8 represents a relative address
    from 128 bytes before the end of the instruction to 127 bytes
    after the end of instruction; similarly rel16/rel32 also
    represents relative addresses, but with the operand size of
    16/32-bit instead of 8-bit like rel8. For a detailed listing,
    please refer to section 3.1.1.3 of volume 2.

  Op/En is short for Operand/Encoding. An operand encoding
    specifies how a ModR/M byte encodes the operands that an
    instruction requires. If a variant of an instruction requires
    operands, then an additional table named “Instruction Operand
    Encoding” is added for explaining the operand encoding, with
    the following structure:


+--------+------------+------------+------------+-----------+
    | Op/En  | Operand 1  | Operand 2  | Operand 3  | Operand 4 |
    +--------+------------+------------+------------+-----------+


    Most instructions require one to two operands. We make use of
    these instructions for our OS and skip the instructions that
    require three or four operands. The operands can be readable
    or writable or both. The symbol (r) denotes a readable
    operand, and (w) denotes a writable operand. For example,
    when Operand 1 field contains ModRM:r/m (r), it means the
    first operand is encoded in r/m field of ModR/M byte, and is
    only readable.

  64/32-bit mode indicates whether the opcode sequence is
    supported in a 64-bit mode and possibly 32-bit mode.

  CPUID Feature Flag indicates indicate a particular CPU feature
    must be available to enable the instruction. An instruction
    is invalid if a CPU does not support the required feature.[margin:
In Linux, the command:

cat /proc/cpuinfo

lists the information of available CPUs and its features in flags
field.
]

    Compat/Leg Mode Many instructions do not have this field, but
      instead is replaced with Compat/Leg Mode, which stands for
      Compatibility or Legacy Mode. This mode enables 64-bit
      variants of instructions to run normally in 16 or 32-bit
      mode. [float MarginTable:
[MarginTable 2:
Notations in Compat/Leg Mode
]


+-----------+----------------------------------------------------------------------------------+
| Notation  | Description                                                                      |
+-----------+----------------------------------------------------------------------------------+
+-----------+----------------------------------------------------------------------------------+
| Valid     | Supported                                                                        |
+-----------+----------------------------------------------------------------------------------+
| I         | Not supported                                                                    |
+-----------+----------------------------------------------------------------------------------+
| N.E.      | The 64-bit opcode cannot be encoded as it overlaps with existing
32-bit opcode. |
+-----------+----------------------------------------------------------------------------------+



]

  Description briefly explains the variant of an instruction in
    the current row.

  Description specifies the purpose of the instructions and how
  an instruction works in detail.

  Operation is pseudo-code that implements an instruction. If a
  description is vague, this section is the next best source to
  understand an assembly instruction. The syntax is described in
  section 3.1.1.9 in volume 2.

  Flags affected lists the possible changes to system flags in
  EFLAGS register.

  Exceptions list the possible errors that can occur when an
  instruction cannot run correctly. This section is valuable for
  OS debugging. Exceptions fall into one of the following
  categories:

• Protected Mode Exceptions

• Real-Address Mode Exception

• Virtual-8086 Mode Exception

• Floating-Point Exception

• SIMD Floating-Point Exception

• Compatibility Mode Exception

• 64-bit Mode Exception

For our OS, we only use Protected Mode Exceptions and
Real-Address Mode Exceptions. The details are in section 3.1.1.13
and 3.1.1.14, volume 2.

  Example: jmp instruction

Let's look at our good old jmp instruction. First, the opcode
table:




+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| Opcode          | Instruction   | Op/

En  | 64-bit Mode  | Compat/Leg Mode  | Description                                                                                    |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| EB cb           | JMP rel8      | D        | Valid        | Valid            | Jump short, RIP = RIP + 8-bit displacement sign extended to
64-bits                           |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| E9 cw           | JMP rel16     | D        | N.S.         | Valid            | Jump near, relative, displacement relative to next instruction.
Not supported in 64-bit mode. |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| E9 cd           | JMP rel32     | D        | Valid        | Valid            | Jump near, relative, RIP = RIP + 32-bit displacement sign
extended to 64-bits                 |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| FF /4           | JMP r/m16     | M        | N.S.         | Valid            | Jump near, absolute indirect, address = zero- extended r/m16. Not
supported in 64-bit mode    |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| FF /4           | JMP r/m32     | M        | N.S.         | Valid            | Jump near, absolute indirect, address given in r/m32. Not
supported in 64-bit mode            |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| FF /4           | JMP r/m64     | M        | Valid        | N.E              | Jump near, absolute indirect, RIP = 64-Bit offset from register
or memory                     |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| EA cd           | JMP ptr16:16  | D        | Inv.         | Valid            | Jump far, absolute, address given in operand                                                   |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| EA cp           | JMP ptr16:32  | D        | Inv.         | Valid            | Jump far, absolute, address given in operand                                                   |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| FF /5           | JMP m16:16    | D        | Valid        | Valid            | Jump far, absolute indirect, address given in m16:16                                           |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| FF /5           | JMP m16:32    | D        | Valid        | Valid            | Jump far, absolute indirect, address given in m16:32                                           |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+
| REX.W + FF /5   | JMP m16:64    | D        | Valid        | N.E.             | Jump far, absolute indirect, address given in m16:64                                           |
+-----------------+---------------+----------+--------------+------------------+------------------------------------------------------------------------------------------------+


<jmp-instruction>



Each row lists a variant of jmp instruction. The first column has
the opcode EB cb, with an equivalent symbolic form jmp rel8.
Here, rel8 means 128 bytes offset, counting from the end of the
instruction. The end of an instruction is the next byte after the
last byte of an instruction. To make it more concrete, consider
this assembly code:

main:

  jmp main

  jmp main2

  jmp main

main2:

  jmp 0x1234

generates the machine code:

[float Table:
[Table 4:
Memory address of each opcode
]


           +-------------------+                  +-------------------------+
           | main              |                  |          main2          |
           +-------------------+                  +-------------------------+
             \downarrow
                                  \downarrow

+----------+--------------+-----+-----+-----+-----+-----+--------------+-----+-----+----+
| Address  |     00       | 01  | 02  | 03  | 04  | 05  |     06       | 07  | 08  | 09 |
+----------               +-----+-----+-----+-----+-----+--------------+-----+-----+----+
+----------+--------------+-----+-----+-----+-----+-----+--------------+-----+-----+----+
| Opcode   |     eb       | fe  | eb  | 02  | eb  | fa  |     e9       | 2b  | 12  | 00 |
+----------+--------------+-----+-----+-----+-----+-----+--------------+-----+-----+----+

]

The first jmp main instruction is generated into eb fe and
occupies the addresses 00 and 01; the end of the first jmp main
is at address 02, past the last byte of the first jmp main which
is located at the address 01. The value fe is equivalent to -2,
since eb opcode uses only a byte (8 bits) for relative
addressing. The offset is -2, and the end address of the first
jmp main is 02, adding them together we get 00 which is the
destination address for jumping to.

Similarly, the jmp main2 instruction is generated into eb 02,
which means the offset is +2; the end address of jmp main2 is at
04, and adding together with the offset we get the destination
address is 06, which is the start instruction marked by the label
main2.

The same rule can be applied to rel16 and rel32 encoding. In the
example code, jmp 0x1234 uses rel16 (which means 2-byte offset)
and is generated into e9 2b 12. As the table [jmp-instruction]
shows, e9 opcode takes a cw operand, which is a 2-byte offset
(section 3.1.1.1, volume 2). Notice one strange issue here: the
offset value is 2b 12, while it is supposed to be 34 12. There is
nothing wrong. Remember, rel8/rel16/rel32 is an offset, not an
address. A offset is a distance from a point. Since no label is
given but a number, the offset is calculated from the start of a
program. In this case, the start of the program is the address
00, the end of jmp 0x1234 is the address 09[footnote:
which means 9 bytes was consumed, starting from address 0.
], so the offset is calculated as 0x1234 - 0x9 = 0x122b. That
solved the mystery!

The jmp instructions with opcode FF /4 enable jumping to a near,
absolute address stored in a general-purpose register or a memory
location; or in short, as written in the description, absolute
indirect. The symbol /4 is the column with digit 4 in table [mod-rm-16]
[footnote:
The column with the following fields:

AH

SP

ESP

M45

XMM4

4

100
]. For example:

jmp [0x1234]

is generated into:

ff 26 34 12

Since this is 16-bit code, we use table [mod-rm-16]. Looking up
the table, ModR/M value 26 means disp16, which means a 16-bit
offset from the start of current index[footnote:
Look at the note under the table.
], which is the base address stored in DS register. In this case,
jmp [0x1234] is implicitly understood as jmp [ds:0x1234], which
means the destination address is 0x1234 bytes away from the start
of a data segment.

The jmp instruction with opcode FF /5 enables jumping to a far,
absolute address stored in a memory location (as opposed to /4,
which means stored in a register); in short, a far pointer. To
generate such instruction, the keyword far is needed to tell nasm
we are using a far pointer:

jmp far [eax]

is generated into:

67 ff 28

Since 28 is the value in the 5th column of the table [mod-rm-32][footnote:
Remember the prefix 67 indicates the instruction is used as
32-bit. The prefix only added if the default environment is
assumed as 16-bit when generating code by an assembler.
] that refers to [eax], we successfully generate an instruction
for a far jump. After CPU runs the instruction, the program
counter eip and code segment register cs is set to the memory
address, stored in the memory location that eax points to, and
CPU starts fetching code from the new address in cs and eip. To
make it more concrete, here is an example:



     <Graphics file: C:/Users/Tu Do/os01/book_src/images/04/far_jmp_ex.pdf>




The far address consumes total of 6 bytes in size for a 16-bit
segment and 32-bit address, which is encoded as m16:32 from the
table [jmp-instruction]. As can be seen from the figure above,
the blue part is a segment address, loaded into cs register with
the value 0x1234; the red part is the memory address within that
segment, loaded into eip register with the value 0x5678 and start
executing from there.

Finally, the jmp instructions with EA opcode jump to a direct
absolute address. For example, the instruction:

jmp 0x1234:0x5678

is generated into:

ea 78 56 34 12

The address 0x1234:0x5678 is right next to the opcode, unlike FF
/5 instruction that needs an indirect address in eax register.

We skip the jump instruction with REX prefix, as it is a 64-bit
instruction.



  Examine compiled data

In this section, we will examine how data definition in C maps to
its assembly form. The generated code is extracted from .bss
section. That means, the assembly code displayed has no[footnote:
Actually, code is just a type of data, and is often used for
hijacking into a running program to execute such code. However,
we have no use for it in this book.
], aside from showing that such a value has an equivalent
assembly opcode that represents an instruction.

The code-assembly listing is not random, but is based on Chapter
4 of Volume 1, “Data Type”. The chapter lists fundamental data
types that x86 hardware operates on, and through learning the
generated assembly code, it can be understood how close C maps
its syntax to hardware, and then a programmer can see why C is
appropriate for OS programming. The specific objdump command used
in this section will be:



$ objdump -z -M intel -S -D <object file> | less



Note: zero bytes are hidden with three dot symbols: ... To show
all the zero bytes, we add -z option.

  Fundamental data types

The most basic types that x86 architecture works with are based
on sizes, each is twice as large as the previous one: 1 byte (8
bits), 2 bytes (16 bits), 4 bytes (32 bits), 8 bytes (64 bits)
and 16 bytes (128 bits).



<Graphics file: C:/Users/Tu Do/os01/book_src/images/04/fundamental_data_types.pdf>



These types are simplest: they are just chunks of memory at
different sizes that enables CPU to access memory efficiently.
From the manual, section 4.1.1, volume 1:

Words, doublewords, and quadwords do not need to be aligned in
memory on natural boundaries. The natural boundaries for words,
double words, and quadwords are even-numbered addresses,
addresses evenly divisible by four, and addresses evenly
divisible by eight, respectively. However, to improve the
performance of programs, data structures (especially stacks)
should be aligned on natural boundaries whenever possible. The
reason for this is that the processor requires two memory
accesses to make an unaligned memory access; aligned accesses
require only one memory access. A word or doubleword operand that
crosses a 4-byte boundary or a quadword operand that crosses an
8-byte boundary is considered unaligned and requires two separate
memory bus cycles for access.

Some instructions that operate on double quadwords require memory
operands to be aligned on a natural boundary. These instructions
generate a general-protection exception (#GP) if an unaligned
operand is specified. A natural boundary for a double quadword is
any address evenly divisible by 16. Other instructions that
operate on double quadwords permit unaligned access (without
generating a general-protection exception). However, additional
memory bus cycles are required to access unaligned data from
memory.

In C, the following primitive types (must include stdint.h) maps
to the fundamental types:

  Source

  #include <stdint.h>



uint8_t @|\color{red}\bfseries byte|@ = 0x12;

uint16_t @|\color{blue}\bfseries word|@ = 0x1234;

uint32_t @|\color{green}\bfseries dword|@ = 0x12345678;

uint64_t @|\color{magenta}\bfseries qword|@ = 0x123456789abcdef;

unsigned __int128 @|\color{cyan}\bfseries dqword1|@ =  (__int128)
0x123456789abcdef;

unsigned __int128 @|\color{cyan}\bfseries dqword2|@ =  (__int128)
0x123456789abcdef << 64;



int main(int argc, char *argv[]) {

        return 0;

}

  Assembly

  0804a018 <byte>:

   804a018:       12 00                   adc    al,BYTE PTR
  [eax]



  0804a01a <word>:

   804a01a:       34 12                   xor    al,0x12



  0804a01c <dword>:

   804a01c:       78 56                   js     804a074
  <_end+0x48>

   804a01e:       34 12                   xor    al,0x12



  0804a020 <qword>:

   804a020:       ef                      out    dx,eax

   804a021:       cd ab                   int    0xab

   804a023:       89 67 45                mov    DWORD PTR
  [edi+0x45],esp

   804a026:       23 01                   and    eax,DWORD PTR
  [ecx]



  0000000000601040 <dqword1>:

    601040:       ef                      out    dx,eax

    601041:       cd ab                   int    0xab

    601043:       89 67 45                mov    DWORD PTR
  [rdi+0x45],esp

    601046:       23 01                   and    eax,DWORD PTR
  [rcx]

    601048:       00 00                   add    BYTE PTR
  [rax],al

    60104a:       00 00                   add    BYTE PTR
  [rax],al

    60104c:       00 00                   add    BYTE PTR
  [rax],al

    60104e:       00 00                   add    BYTE PTR
  [rax],al



  0000000000601050 <dqword2>:

    601050:       00 00                   add    BYTE PTR
  [rax],al

    601052:       00 00                   add    BYTE PTR
  [rax],al

    601054:       00 00                   add    BYTE PTR
  [rax],al

    601056:       00 00                   add    BYTE PTR
  [rax],al

    601058:       ef                      out    dx,eax

    601059:       cd ab                   int    0xab

    60105b:       89 67 45                mov    DWORD PTR
  [rdi+0x45],esp

    60105e:       23 01                   and    eax,DWORD PTR
  [rcx]



gcc generates the variables byte, word, dword, qword, dqword1,
dword2, written earlier, with their respective values highlighted
in the same colors; variables of the same type are also
highlighted in the same color. Since this is data section, the
assembly listing carries no meaning. When byte is declared with
uint8_t, gcc guarantees that the size of byte is always 1 byte.
But, an alert reader might notice the 00 value next to the 12
value in the byte variable. This is normal, as gcc avoid memory
misalignment by adding extra padding bytespadding bytes. To make
it easier to see, we look at readelf output of .data section:



$ readelf -x .data hello



the output is (the colors mark which values belong to which
variables):

Hex dump of section '.data':

  0x00601020 00000000 00000000 00000000 00000000 ................

  0x00601030 12003412 78563412 efcdab89 67452301 ..4.xV4.....gE#.

  0x00601040 efcdab89 67452301 00000000 00000000 ....gE#.........

  0x00601050 00000000 00000000 efcdab89 67452301 ............gE#.

As can be seen in the readelf output, variables are allocated
storage space according to their types and in the declared order
by the programmer (the colors correspond the the variables).
Intel is a little-endian machine, which means smaller addresses
hold bytes with smaller values, larger addresses hold byte with
larger values. For example, 0x1234 is displayed as 34 12; that
is, 34 appears first at address 0x601032, then 12 at 0x601033.
The decimal values within a byte is unchanged, so we see 34 12
instead of 43 21. This is quite confusing at first, but you will
get used to it soon.

Also, isn't it redundant when char type is always 1 byte already
and why do we bother adding int8_t? The truth is, char type is
not guaranteed to be 1 byte in size, but only the minimum of 1
byte in size. In C, a byte is defined to be the size of a char,
and a char is defined to be smallest addressable unit of the
underlying hardware platform. There are hardware devices that the
smallest addressable unit is 16 bit or even bigger, which means
char is 2 bytes in size and a “byte” in such platforms is
actually 2 units of 8-bit bytes.

Not all architectures support the double quadword type. Still,
gcc does provide support for 128-bit number and generate code
when a CPU supports it (that is, a CPU must be 64-bit). By
specifying a variable of type __int128 or unsigned __int128, we
get a 128-bit variable. If a CPU does not support 64-bit mode,
gcc throws an error.

The data types in C, which represents the fundamental data types,
are also called unsigned numbers. Other than numerical
calculations, unsigned numbers are used as a tool for structuring
data in memory; we will this application see later in the book,
when various data structures are organized into bit groups.

In all the examples above, when the value of a variable with
smaller size is assigned to a variable with larger size, the
value easily fits in the larger variable. On the contrary, the
value of a variable with larger size is assigned to a variable
with smaller size, two scenarios occur:

• The value is greater than the maximum value of the variable
  with smaller layout, so it needs truncating to the size of the
  variable and causing incorrect value.

• The value is smaller than the maximum value of the variable
  with a smaller layout, so it fits the variable.

However, the value might be unknown until runtime and can be
value, it is best not to let such implicit conversion handled by
the compiler, but explicitly controlled by a programmer.
Otherwise it will cause subtle bugs that are hard to catch as the
erroneous values might rarely be used to reproduce the bugs.

  Pointer Data Types

Pointers are variables that hold memory addresses. x86 works with
2 types of pointers:

  Near pointer is a 16-bit/32-bit offset within a segment, also
  called effective address.

  Far pointer is also an offset like a near pointer, but with an
  explicit segment selector.



     <Graphics file: C:/Users/Tu Do/os01/book_src/images/04/pointer_data_type.pdf>




C only provides near pointer, since far pointer is platform
dependent, such as x86. In application code, you can assume that
the address of current segment starts at 0, so the offset is
actually any memory addres from 0 to the maximum address.

  Source

  #include <stdint.h>



int8_t i = 0;

int8_t @|\color{red}\bfseries *p1|@ =  (int8_t *) 0x1234;

int8_t @|\color{blue}\bfseries *p2|@ =  &i;



int main(int argc, char *argv[]) {

        return 0;

}

  Assembly

  0000000000601030 <p1>:

    601030:       34 12                   xor    al,0x12

    601032:       00 00                   add    BYTE PTR
  [rax],al

    601034:       00 00                   add    BYTE PTR
  [rax],al

    601036:       00 00                   add    BYTE PTR
  [rax],al

  0000000000601038 <p2>:

    601038:       41 10 60 00             adc    BYTE PTR
  [r8+0x0],spl

    60103c:       00 00                   add    BYTE PTR
  [rax],al

    60103e:       00 00                   add    BYTE PTR
  [rax],al



  Disassembly of section .bss:



  0000000000601040 <__bss_start>:

    601040:       00 00                   add    BYTE PTR
  [rax],al

  0000000000601041 <i>:

    601041:       00 00                   add    BYTE PTR
  [rax],al

    601043:       00 00                   add    BYTE PTR
  [rax],al

    601045:       00 00                   add    BYTE PTR
  [rax],al

    601047:       00                      .byte 0x0

The pointer p1 holds a direct address with the value 0x1234. The
pointer p2 holds the address of the variable i. Note that both
the pointers are 8 bytes in size (or 4-byte, if 32-bit).

  Bit Field Data Type

A bit fieldbit field is a contiguous sequence of bits. Bit fields
allow data structuring at bit level. For example, a 32-bit data
can hold multiple bit fields that represent multiples different
pieces of information, such as bits 0-4 specifies the size of a
data structure, bit 5-6 specifies permissions and so on. Data
structures at the bit level are common for low-level programming.



     <Graphics file: C:/Users/Tu Do/os01/book_src/images/04/bit_field_data_type.pdf>




  Source

  struct bit_field {

    int data1:8;

    int data2:8;

    int data3:8;

    int data4:8;

};



struct bit_field2 {

    int data1:8;

    int data2:8;

    int data3:8;

    int data4:8;

    char data5:4;

};



struct normal_struct {

    int data1;

    int data2;

    int data3;

    int data4;

};



struct normal_struct @|\color{red}\bfseries ns|@ = {

    .data1 = @|\color{red}\bfseries 0x12345678|@,

    .data2 = @|\color{red}\bfseries 0x9abcdef0|@,

    .data3 = @|\color{red}\bfseries 0x12345678|@,

    .data4 = @|\color{red}\bfseries 0x9abcdef0|@,

};



int @|\color{blue}\bfseries i|@ = 0x12345678;



struct bit_field @|\color{magenta}\bfseries bf|@ = {

    .data1 = @|\color{magenta}\bfseries 0x12|@,

    .data2 = @|\color{magenta}\bfseries 0x34|@,

    .data3 = @|\color{magenta}\bfseries 0x56|@,

    .data4 = @|\color{magenta}\bfseries 0x78|@

};



struct bit_field2 @|\color{green}\bfseries bf2|@ = {

    .data1 = @|\color{green}\bfseries 0x12|@,

    .data2 = @|\color{green}\bfseries 0x34|@,

    .data3 = @|\color{green}\bfseries 0x56|@,

    .data4 = @|\color{green}\bfseries 0x78|@,

    .data5 = @|\color{green}\bfseries 0xf|@

};



int main(int argc, char *argv[]) {

    return 0;

}

  Assembly

  Each variable and its value are given a unique color in the
  assembly listing below:

  0804a018 <ns>:

   804a018: 78 56                   js     804a070 <_end+0x34>

   804a01a: 34 12                   xor    al,0x12

   804a01c: f0 de bc 9a 78 56 34    lock fidivr WORD PTR
  [edx+ebx*4+0x12345678]

   804a023: 12

   804a024: f0 de bc 9a 78 56 34    lock fidivr WORD PTR
  [edx+ebx*4+0x12345678]

   804a02b: 12

  0804a028 <i>:

   804a028: 78 56                   js     804a080 <_end+0x44>

   804a02a: 34 12                   xor    al,0x12

  0804a02c <bf>:

   804a02c: 12 34 56                adc    dh,BYTE PTR
  [esi+edx*2]

   804a02f: 78 12                   js     804a043 <_end+0x7>

  0804a030 <bf2>:

   804a030: 12 34 56                adc    dh,BYTE PTR
  [esi+edx*2]

   804a033: 78 0f                   js     804a044 <_end+0x8>

   804a035: 00 00                   add    BYTE PTR [eax],al

   804a037: 00                      .byte 0x0

The sample code creates 4 variables: ns, i, bf, bf2. The
definition of normal_struct and bit_field structs both specify 4
integers. bit_field specifies additional information next to its
member name, separated by a colon, e.g. .data1 : 8. This extra
information is the bit width of each bit group. It means, even
though defined as an int, .data1 only consumes 8 bit of
information. If additional data members are specified after
.data1, two scenarios happen:

• If the new data members fit within the remaining bits after
  .data, which are 24 bits[footnote:
Since .data1 is declared as an int, 32 bits are still allocated,
but .data1 can only access 8 bits of information.
], then the total size of bit_field struct is still 4 bytes, or
  32 bits.

• If the new data members don't fit, then the remaining 24 bits
  (3 bytes) are still allocated. However, the new data members
  are allocated brand new storages, without using the previous 24
  bits.

In the example, the 4 data members: .data1, .data2, .data3 and
.data4, each can access 8 bits of information, and together can
access all of 4 bytes of the integer first declared by .data1. As
can be seen by the generated assembly code, the values of bf are
follow natural order as written in the C code: 12 34 56 78, since
each value is a separate members. In contrast, the value of i is
a number as a whole, so it is subject to the rule of little
endianess and thus contains the value 78 56 34 12. Note that at
804a02f, is the address of the final byte in bf, but next to it
is a number 12, despite 78 is the last number in it. This extra
number 12 does not belong to the value of bf. objdump is just
being confused that 78 is an opcode; 78 corresponds to js
instruction, and it requires an operand. For that reason, objdump
grabs whatever the next byte after 78 and put it there. objdump
is a tool to display assembly code after all. A better tool to
use is gdb that we will learn in the next chapter. But for this
chapter, objdump suffices.

Unlike bf, each data member in ns is allocated fully as an
integer, 4 bytes each, 16 bytes in total. As we can see, bit
field and normal struct are different: bit field structure data
at the bit level, while normal struct works at byte level.

Finally, the struct of bf2[footnote:
bit_field2
] is the same of bf[footnote:
bit_field
], except it contains one more data member: .data5, and is
defined as an integer. For this reason, another 4 bytes are
allocated just for .data5, even though it can only access 8 bits
of information, and the final value of bf2 is: 12 34 56 78 0f 00
00 00. The remaining 3 bytes must be accessed by the mean of a
pointer, or casting to another data type that can fully access
all 4 bytes..

What happens when the definition of bit_field struct and bf
variable are changed to:

  struct bit_field {

      int data1:8;

  };

  struct bit_field bf = {

      .data1 = 0x1234,

  };

  What will be the value of .data1?

  What happens when the definition of bit_field2 struct is
  changed to:

  struct bit_field2 {

      int data1:8;

      int data5:32;

  };

  What is layout of a variable of type bit_field2?

  String Data Types

Although share the same name, string as defined by x86 is
different than a string in C. x86 defines string as “continuous
sequences of bits, bytes, words, or doublewords”. On the other
hand, C defines a string as an array of 1-byte characters with a
zero as the last element of the array to make a null-terminated
string. This implies that strings in x86 are arrays, not C
strings. A programmer can define an array of bytes, words or
doublewords with char or uint8_t, short or uint16_t and int or
uint32_t, except an array of bits. However, such a feature can be
easily implemented, as an array of bits is essentially any array
of bytes, or words or doublewords, but operates at the bit level.

The following code demonstrates how to define array (string) data
types:

  Source

  #include <stdint.h>



uint8_t @|\color{red}\bfseries a8[2]|@ = {0x12, 0x34};

uint16_t @|\color{blue}\bfseries a16[2]|@ = {0x1234, 0x5678};

uint32_t @|\color{magenta}\bfseries a32[2]|@ = {0x12345678,
0x9abcdef0};

uint64_t @|\color{green}\bfseries a64[2]|@ = {0x123456789abcdef0,
0x123456789abcdef0};



int main(int argc, char *argv[])

{

    return 0;

}

  Assembly

  0804a018 <a8>:

   804a018: 12 34 00                adc    dh,BYTE PTR
  [eax+eax*1]

   804a01b: 00 34 12                add    BYTE PTR
  [edx+edx*1],dh

  0804a01c <a16>:

   804a01c: 34 12                   xor    al,0x12

   804a01e: 78 56                   js     804a076 <_end+0x3a>

  0804a020 <a32>:

   804a020: 78 56                   js     804a078 <_end+0x3c>

   804a022: 34 12                   xor    al,0x12

   804a024: f0 de bc 9a f0 de bc    lock fidivr WORD PTR
  [edx+ebx*4-0x65432110]

   804a02b: 9a

  0804a028 <a64>:

   804a028: f0 de bc 9a 78 56 34    lock fidivr WORD PTR
  [edx+ebx*4+0x12345678]

   804a02f: 12

   804a030: f0 de bc 9a 78 56 34    lock fidivr WORD PTR
  [edx+ebx*4+0x12345678]

   804a037: 12

Despite a8 is an array with 2 elements, each is 1-byte long, but
it is still allocated with 4 bytes. Again, to ensure natural
alignment for best performance, gcc pads extra zero bytes. As
shown in the assembly listing, the actual value of a8 is 12 34 00
00, with a8[0] equals to 12 and a8[1] equals to 34.

Then it comes a16 with 2 elements, each is 2-byte long. Since 2
elements are 4 bytes in total, which is in the natural alignment,
gcc pads no byte. The value of a16 is 34 12 78 56, with a16[0]
equals to 34 12 and a16[1] equals to 78 56. Note that, objdump is
confused again, as de is the opcode for the instruction fidivr
(short of reverse divide) that requires another operand, so
objdump grabs whatever the next bytes that makes sense to it for
creating “an operand”. Only the highlighted values belong to a32.

Next is a32, with 2 elements, 4 bytes each. Similar to above
arrays, the value of a32[0] is 78 56 34 12, the value of a32[1]
is f0 de bc 9a, exactly what is assigned in the C code.

Finally is a64, also with 2 elements, but 8 bytes each. The total
size of a64 is 16 bytes, which is in the natural alignment,
therefore no padding bytes added. The values of both a64[0] and
a64[1] are the same: f0 de bc 9a 78 56 34 12, that got
misinterpreted to fidivr instruction.

[float Figure:
[Figure 0.13:
a8, a16, a32 and a64 memory layouts
]

a8:  
+----------+
| 12 | 34  |
+----------+


a16:
+--------------------+
| 34 12   | 78 56    |
+--------------------+


a32:
+----------------------------------------+
| 78 56 34 12       | f0 de bc 9a        |
+----------------------------------------+


a64:
+---------------------------------------------------------------------------------+
| f0 de bc 9a 78 56 34 12               | f0 de bc 9a 78 56 34 12   
             |
+---------------------------------------------------------------------------------+

]

However, beyond one-dimensional arrays that map directly to
hardware string type, C provides its own syntax for
multi-dimensional arrays:

  Source

  #include <stdint.h>



uint8_t @|\color{red}\bfseries a2[2][2]|@ = {

    {0x12, 0x34},

    {0x56, 0x78}

};



uint8_t @|\color{blue}\bfseries a3[2][2][2]|@ = {

    {{0x12, 0x34},

     {0x56, 0x78}},

    {{0x9a, 0xbc},

     {0xde, 0xff}},

};



int main(int argc, char *argv[]) {

    return 0;

}

  Assembly

  0804a018 <a2>:

   804a018: 12 34 56                adc    dh,BYTE PTR
  [esi+edx*2]

   804a01b: 78 12                   js     804a02f <_end+0x7>

  0804a01c <a3>:

   804a01c: 12 34 56                adc    dh,BYTE PTR
  [esi+edx*2]

   804a01f: 78 9a                   js     8049fbb
  <_DYNAMIC+0xa7>

   804a021: bc                      .byte 0xbc

   804a022: de ff                   fdivrp st(7),st



Technically, multi-dimensional arrays are like normal arrays: in
the end, the total size is translated into flat allocated bytes.
A 2 x 2 array is allocated with 4 bytes; a 2\times2\times2
 array
is allocated with 8 bytes, as can be seen in the assembly listing
of a2[footnote:
Again, objdump is confused and put the number 12 next to 78 in a3
listing.
] and a3. In low-level assembly code, the representation is the
same between a[4] and a[2][2]. However, in high-level C code, the
difference is tremendous. The syntax of multi-dimensional array
enables a programmer to think with higher level concepts, instead
of translating manually from high-level concepts to low-level
code and work with high-level concepts in his head at the same
time.

The following two-dimensional array can hold a list of 2 names
with the length of 10:

  char names[2][10] = {

    "John Doe",

    "Jane Doe"

};

  To access a name, we simply adjust the column index[footnote:
The left index is called column index since it changes the index
based on a column.
] e.g. names[0], names[1]. To access individual character within
  a name, we use the row index[footnote:
Same with column index, the right index is called row index since
it changes the index based on a row.
] e.g. names[0][0] gives the character “J”, names[0][1] gives the
  character “o” and so on.

  Without such syntax, we need to create a 20-byte array e.g.
  names[20], and whenever we want to access a character e.g. to
  check if the names contains with a number in it, we need to
  calculate the index manually. It would be distracting, since we
  constantly need to switch thinkings between the actual problem
  and the translate problem.

  Since this is a repeating pattern, C abstracts away this
  problem with the syntax for define and manipulating
  multi-dimensional array. Through this example, we can clearly
  see the power of abstraction through language can give us. It
  would be ideal if a programmer is equipped with such power to
  define whatever syntax suitable for a problem at hands. Not
  many languages provide such capacity. Fortunately, through C
  macro, we can partially achieve that goal .

In all cases, an array is guaranteed to generate contiguous bytes
of memory, regardless of the dimensions it has.

What is the difference between a multi-dimensional array and an
array of pointers, or even pointers of pointers?

  Examine compiled code

This section will explore how compiler transform high level code
into assembly code that CPU can execute, and see how common
assembly patterns help to create higher level syntax. -S option
is added to objdump to better demonstrate the connection between
high and low level code.

In this section, the option --no-show-raw-insn is added to
objdump command to omit the opcodes for clarity:



$ objdump --no-show-raw-insn -M intel -S -D <object file> | less



  Data Transfer

Previous section explores how various types of data are created,
and how they are laid out in memory. Once memory storages are
allocated for variables, they must be accessible and writable.
Data transfer instructions move data (bytes, words, doublewords
or quadwords) between memory and registers, and between
registers, effectively read from a storage source and write to
another storage source.

  Source

  #include <stdint.h>



int32_t i = 0x12345678;



int main(int argc, char *argv[]) {

        int j = i;

        int k = 0xabcdef;



        return 0;

}

  Assembly

  080483db <main>:

  #include <stdint.h>

  int32_t i = 0x12345678;

  int main(int argc, char *argv[]) {

   80483db:       push   ebp

   80483dc:       mov    ebp,esp

   80483de:       sub    esp,0x10

          int j = i;

   80483e1:       mov    eax,ds:0x804a018

   80483e6:       mov    DWORD PTR [ebp-0x8],eax

          int k = 0xabcdef;

   80483e9:       mov    DWORD PTR [ebp-0x4],0xabcdef

          return 0;

   80483f0:       mov    eax,0x0

  }

   80483f5:       leave

   80483f6:       ret

   80483f7:       xchg   ax,ax

   80483f9:       xchg   ax,ax

   80483fb:       xchg   ax,ax

   80483fd:       xchg   ax,ax

   80483ff:       nop

The general data movement is performed with the mov instruction.
Note that despite the instruction being called mov, it actually
copies data from one destination to another.

The red instruction copies data from the register esp to the
register ebp. This mov instruction moves data between registers
and is assigned the opcode 89.

The blue instructions copies data from one memory location (the i
variable) to another (the j variable). There exists no data
movement from memory to memory; it requires two mov instructions,
one for copying the data from a memory location to a register,
and one for copying the data from the register to the destination
memory location.

The pink instruction copies an immediate value into memory.
Finally, the green instruction copies immediate data into a
register.

  Expressions

  Source

  int expr(int i, int j)

{

    int add            = i + j;

    int sub            = i - j;

    int mul            = i * j;

    int div            = i / j;

    int mod            = i % j;

    int neg            = -i;

    int and            = i & j;

    int or             = i | j;

    int xor            = i ^ j;

    int not            = ~i;

    int shl            = i << 8;

    int shr            = i >> 8;

    char equal1        = (i == j);

    int equal2         = (i == j);

    char greater       = (i > j);

    char less          = (i < j);

    char greater_equal = (i >= j);

    char less_equal    = (i <= j);

    int logical_and    = i && j;

    int logical_or     = i || j;

    ++i;

    --i;

    int i1             = i++;

    int i2             = ++i;

    int i3             = i--;

    int i4             = --i;



    return 0;

}



int main(int argc, char *argv[]) {

    return 0;

}

  Assembly

  The full assembly listing is really long. For that reason, we
  examine expression by expression.

  Expression: int add = i + j;

     80483e1:       mov    edx,DWORD PTR [ebp+0x8]

     80483e4:       mov    eax,DWORD PTR [ebp+0xc]

     80483e7:       add    eax,edx

     80483e9:       mov    DWORD PTR [ebp-0x34],eax

    The assembly code is straight forward: variable i and j are
    stored in eax and edx respectively, then added together with
    the add instruction, and the final result is stored into eax.
    Then, the result is saved into the local variable add, which
    is at the location [ebp-0x34].

  Expression: int sub = i - j;

    80483ec:       mov    eax,DWORD PTR [ebp+0x8]

    80483ef:       sub    eax,DWORD PTR [ebp+0xc]

    80483f2:       mov    DWORD PTR [ebp-0x30],eax

    Similar to add instruction, x86 provides a sub instruction
    for subtraction. Hence, gcc translates a subtraction into sub
    instruction, with eax is reloaded with i, as eax still
    carries the result from previous expression. Then, j is
    subtracted from i. After the subtraction, the value is saved
    into the variable sub, at location [ebp-0x30].

  Expression: int mul = i * j;

    80483f5:       mov    eax,DWORD PTR [ebp+0x8]

    80483f8:       imul   eax,DWORD PTR [ebp+0xc]

    80483fc:       mov    DWORD PTR [ebp-0x34],eax

    Similar to sub instruction, only eax is reloaded, since it
    carries the result of previous calculation. imul performs
    signed multiply[footnote:
Unsigned multiply is perform by mul instruction.
]. eax is first loaded with i, then is multiplied with j and
    stored the result back into eax, then stored into the
    variable mul at location [ebp-0x34].

  Expression: int div = i / j;

    80483ff:       mov    eax,DWORD PTR [ebp+0x8]

    8048402:       cdq

    8048403:       idiv   DWORD PTR [ebp+0xc]

    8048406:       mov    DWORD PTR [ebp-0x30],eax

    Similar to imul, idiv performs sign divide. But, different
    from imul above idiv only takes one operand:

    1. First, i is reloaded into eax.

    2. Then, cdq converts the double word value in eax into a
      quadword value stored in the pair of registers edx:eax, by
      copying the signed (bit 31[superscript:th]) of the value in eax into every bit position in edx. The pair
      edx:eax is the dividend, which is the variable i, and the
      operand to idiv is the divisor, which is the variable j.

    3. After the calculation, the result is stored into the pair
      edx:eax registers, with the quotient in eax and remainder
      in edx. The quotient is stored in the variable div, at
      location [ebp-0x30].

  Expression: int mod = i % j;

    8048409:       mov    eax,DWORD PTR [ebp+0x8]

    804840c:       cdq

    804840d:       idiv   DWORD PTR [ebp+0xc]

    8048410:       mov    DWORD PTR [ebp-0x2c],edx

    The same idiv instruction also performs the modulo operation,
    since it also calculates a remainder and stores in the
    variable mod, at location [ebp-0x2c].

  Expression: int neg = -i;

    8048413:       mov    eax,DWORD PTR [ebp+0x8]

    8048416:       neg    eax

    8048418:       mov    DWORD PTR [ebp-0x28],eax

    neg replaces the value of operand (the destination operand)
    with its two's complement (this operation is equivalent to
    subtracting the operand from 0). In this example, the value i
    in eax is replaced replaced with -i using neg instruction.
    Then, the new value is stored in the variable neg at
    [ebp-0x28].

  Expression: int and = i & j;

    804841b:        mov    eax,DWORD PTR [ebp+0x8]

    804841e:        and    eax,DWORD PTR [ebp+0xc]

    8048421:        mov    DWORD PTR [ebp-0x24],eax

    and performs a bitwise AND operation on two operands, and
    stores the result in the destination operand, which is the
    variable and at [ebp-0x24].

  Expression: int or = i | j;

    8048424:       mov    eax,DWORD PTR [ebp+0x8]

    8048427:       or     eax,DWORD PTR [ebp+0xc]

    804842a:       mov    DWORD PTR [ebp-0x20],eax

    Similar to and instruction, or performs a bitwise OR
    operation on two operands, and stores the result in the
    destination operand, which is the variable or at [ebp-0x20]
    in this case.

  Expression: int xor = i ^ j;

    804842d:       mov    eax,DWORD PTR [ebp+0x8]

    8048430:       xor    eax,DWORD PTR [ebp+0xc]

    8048433:       mov    DWORD PTR [ebp-0x1c],eax

    Similar to and/or instruction, xor performs a bitwise XOR
    operation on two operands, and stores the result in the
    destination operand, which is the variable xor at [ebp-0x1c].

  Expression: int not = ~i;

    8048436:       mov    eax,DWORD PTR [ebp+0x8]

    8048439:       not    eax

    804843b:       mov    DWORD PTR [ebp-0x18],eax

    not performs a bitwise NOT operation (each 1 is set to 0, and
    each 0 is set to 1) on the destination operand and stores the
    result in the destination operand location, which is the
    variable not at [ebp-0x18].

  Expression: int shl = i << 8;

    804843e:       mov    eax,DWORD PTR [ebp+0x8]

    8048441:	   shl    eax,0x8

    8048444:	   mov    DWORD PTR [ebp-0x14],eax

    shl (shift logical left) shifts the bits in the destination
    operand to the left by the number of bits specified in the
    source operand. In this case, eax stores i and shl shifts eax
    by 8 bits to the left. A different name for shl is sal (shift
    arithmetic left). Both can be used synonymous. Finally, the
    result is stored in the variable shl at [ebp-0x14].

    Here is a visual demonstration of shl/sal and shr
    instructions:



    After shifting to the left, the right most bit is set for
    Carry Flag in EFLAGS register.

  Expression: int shr = i >> 8;

    8048447:       mov    eax,DWORD PTR [ebp+0x8]

    804844a:   	sar    eax,0x8

    804844d:   	mov    DWORD PTR [ebp-0x10],eax

    sar is similar to shl/sal, but shift bits to the right and
    extends the sign bit. For right shift, shr and sar are two
    different instructions. shr differs to sar is that it does
    not extend the sign bit. Finally, the result is stored in the
    variable shr at [ebp-0x10].

    In the figure (b), notice that initially, the sign bit is 1,
    but after 1-bit and 10-bit shiftings, the shifted-out bits
    are filled with zeros.

    [float Figure:
[Figure 0.14:
SAR Instruction Operation (Source: Figure 7-8, Volume 1)
]

     <Graphics file: C:/Users/Tu Do/os01/book_src/images/04/sar.pdf>

]

    With sar, the sign bit (the most significant bit) is
    preserved. That is, if the sign bit is 0, the new bits always
    get the value 0; if the sign bit is 1, the new bits always
    get the value 1.

  Expression: char equal1 = (i == j);

    8048450:       mov    eax,DWORD PTR [ebp+0x8]

    8048453:       cmp    eax,DWORD PTR [ebp+0xc]

    8048456:       sete   al

    8048459:       mov    BYTE PTR [ebp-0x41],al

    cmp and variants of the variants of set instructions make up
    all the logical comparisons. In this expression, cmp compares
    variable i and j; then sete stores the value 1 to al register
    if the comparison from cmp earlier is equal, or stores 0
    otherwise. The general name for variants of set instruction
    is called SETcc. The suffix cc denotes the condition being
    tested for in EFLAGS register. Appendix B in volume 1,
    “EFLAGS Condition Codes”, lists the conditions it is possible
    to test for with this instruction. Finally, the result is
    stored in the variable equal1 at [ebp-0x41].

  Expression: int equal2 = (i == j);

    804845c:       mov    eax,DWORD PTR [ebp+0x8]

    804845f:       cmp    eax,DWORD PTR [ebp+0xc]

    8048462:       sete   al

    8048465:       movzx  eax,al

    8048468:       mov    DWORD PTR [ebp-0xc],eax

    Similar to equality comparison, this expression also compares
    for equality, with an exception that the result is stored in
    an int type. For that reason, one more instruction is a
    added: movzx instruction, a variant of mov that copies the
    result into a destination operand and fills the remaining
    bytes with 0. In this case, since eax is 4-byte wide, after
    copying the first byte in al, the remaining bytes of eax are
    filled with 0 to ensure the eax carries the same value as al.

    [float Figure:
[Figure 0.15:
movzx instruction
]     [float Figure:
[Sub-Figure a:
eax before movzx
]


+-----+-----+-----+----+
| 12  | 34  | 56  | 78 |
+-----+-----+-----+----+

]     [float Figure:
[Sub-Figure b:
after movzx eax, al
]


+-----+-----+-----+----+
| 00  | 00  | 00  | 78 |
+-----+-----+-----+----+

]
]

  Expression: char greater = (i > j);

    804846b:       mov    eax,DWORD PTR [ebp+0x8]

    804846e:       cmp    eax,DWORD PTR [ebp+0xc]

    8048471:       setg   al

    8048474:       mov    BYTE PTR [ebp-0x40],al

    Similar to equality comparison, but used setg for greater
    comparison instead.

  Expression: char less = (i < j);

    8048477:       mov    eax,DWORD PTR [ebp+0x8]

    804847a:       cmp    eax,DWORD PTR [ebp+0xc]

    804847d:       setl   al

    8048480:       mov    BYTE PTR [ebp-0x3f],al

    Applied setl for less comparison.

  Expression: char greater_equal = (i >= j);

    8048483:       mov    eax,DWORD PTR [ebp+0x8]

    8048486:       cmp    eax,DWORD PTR [ebp+0xc]

    8048489:       setge  al

    804848c:       mov    BYTE PTR [ebp-0x3e],al

    Applied setge for greater or equal comparison.

  Expression: char less_equal = (i <= j);

    804848f:       mov    eax,DWORD PTR [ebp+0x8]

    8048492:       cmp    eax,DWORD PTR [ebp+0xc]

    8048495:       setle  al

    8048498:       mov    BYTE PTR [ebp-0x3d],al

    Applied setle for less than or equal comparison.

  Expression: int logical_and = (i && j);

    804849b:       cmp    DWORD PTR [ebp+0x8],0x0

    804849f:       je     80484ae <expr+0xd3>

    80484a1:       cmp    DWORD PTR [ebp+0xc],0x0

    80484a5:       je     80484ae <expr+0xd3>

    80484a7:       mov    eax,0x1

    80484ac:       jmp    80484b3 <expr+0xd8>

    80484ae:       mov    eax,0x0

    80484b3:       mov    DWORD PTR [ebp-0x8],eax

    Logical AND operator && is one of the syntaxes that is made
    entirely in software[footnote:
That is, there is no equivalent assembly instruction implemented
in hardware.
] with simpler instructions. The algorithm from the assembly code
    is simple:

    1. First, check if i is 0 with the instruction at 0x804849b.

      (a) If true, jump to 0x80484ae and set eax to 0.

      (b) Set the variable logical_and to 0, as it is the next
        instruction after 0x80484ae.

    2. If i is not 0, check if j is 0 with the instruction at
      0x80484a1.

      (a) If true, jump to 0x80484ae and set eax to 0.

      (b) Set the variable logical_and to 0, as it is the next
        instruction after 0x80484ae.

    3. If both i and j are not 0, the result is certainly 1, or
      true.

      (a) Set it accordingly with the instruction at 0x80484a7.

      (b) Then jump over the instruction at 0x80484ae to set the
        variable logical_and at [ebp-0x8] to 0.

  Expression: int logical_or = (i || j);

    80484b6:       cmp    DWORD PTR [ebp+0x8],0x0

    80484ba:       jne    80484c2 <expr+0xe7>

    80484bc:       cmp    DWORD PTR [ebp+0xc],0x0

    80484c0:       je     80484c9 <expr+0xee>

    80484c2:       mov    eax,0x1

    80484c7:       jmp    80484ce <expr+0xf3>

    80484c9:       mov    eax,0x0

    80484ce:       mov    DWORD PTR [ebp-0x4],eax

    Logical OR operator || is similar to logical and above.
    Understand the algorithm is left as an exercise for readers.

  Expression: ++i; and --i; (or i++ and i--)

    80484d1:       add    DWORD PTR [ebp+0x8],0x1

    80484d5:       sub    DWORD PTR [ebp+0x8],0x1

    The syntax of increment and decrement is similar to logical
    AND and logical OR in that it is made from existing
    instruction, that is add. The difference is that the CPU
    actually does has a built-in instruction, but gcc decided not
    to use the instruction because inc and dec cause a partial
    flag register stall, occurs when an instruction modifies a
    part of the flag register and the following instruction is
    dependent on the outcome of the flags (section 3.5.2.6, Intel Optimization Manual, 2016
    ). The manual even suggests that inc and dec should be
    replaced with add and sub instructions (section 3.5.1.1, Intel Optimization Manual, 2016
    ).

  Expression: int i1 = i++;

    80484d9:       mov    eax,DWORD PTR [ebp+0x8]

    80484dc:       lea    edx,[eax+0x1]

    80484df:       mov    DWORD PTR [ebp+0x8],edx

    80484e2:       mov    DWORD PTR [ebp-0x10],eax

    First, i is copied into eax at 80484d9. Then, the value of
    eax + 0x1 is copied into edx as an effective address at
    80484dc. The lea (load effective address) instruction copies
    a memory address into a register. According to Volume 2, the
    source operand is a memory address specified with one of the
    processors addressing modes. This means, the source operand
    must be specified by the addressing modes defined in
    16-bit/32-bit ModR/M Byte tables, [mod-rm-16] and [mod-rm-32]
    .

    After loading the incremented value into edx, the value of i
    is increased by 1 at 80484df. Finally, the previous i value
    is stored back to i1 at [ebp-0x8] by the instruction at
    80484e2.

  Expression: int i2 = ++i;

    80484e5:       add    DWORD PTR [ebp+0x8],0x1

    80484e9:       mov    eax,DWORD PTR [ebp+0x8]

    80484ec:       mov    DWORD PTR [ebp-0xc],eax

    The primary differences between this increment syntax and the
    previous one are:

    • add is used instead of lea to increase i directly.

    • the newly incremented i is stored into i2 instead of the
      old value.

    • the expression only costs 3 instructions instead of 4.

    This prefix-increment syntax is faster than the post-fix one
    used previously. It might not matter much which version to
    use if the increment is only used once or a few hundred times
    in a small loop, but it matters when a loop runs millions or
    more times. Also, depends on different circumstances, it is
    more convenient to use one over the other e.g. if i is an
    index for accessing an array, we want to use the old value
    for accessing previous array element and newly incremented i
    for current element.

  Expression: int i3 = i--;

    80484ef:       mov    eax,DWORD PTR [ebp+0x8]

    80484f2:       lea    edx,[eax-0x1]

    80484f5:       mov    DWORD PTR [ebp+0x8],edx

    80484f8:       mov    DWORD PTR [ebp-0x8],eax

    Similar to i++ syntax, and is left as an exercise to readers.

  Expression: int i4 = --i;

    80484fb:       sub    DWORD PTR [ebp+0x8],0x1

    80484ff:       mov    eax,DWORD PTR [ebp+0x8]

    8048502:       mov    DWORD PTR [ebp-0x4],eax

    Similar to ++i syntax, and is left as an exercise to readers.

Read section 3.5.2.4, “Partial Register Stalls” to understand
register stalls in general.

  Read the sections from 7.3.1 to 7.3.7 in volume 1.

  Stack

A stack is a contiguous array of memory locations that holds a
collection of discrete data. When a new element is added, a stack
grows down in memory toward lesser addresses, and shrinks up
toward greater addresses when an element is removed. x86 uses the
esp register to point to the top of the stack, at the newest
element. A stack can be originated anywhere in main memory, as
esp can be set to any memory address. x86 provides two operations
for manipulating stacks:

• push instruction and its variants add a new element on top of
  the stack

• pop instructions and its variants remove the top-most element
  from the stack.






+----------+----+
| 0x10000  | 00 |
+----------+----+
| 0x10001  | 00 |
+----------+----+
| 0x10002  | 00 |
+----------+----+
| 0x10003  | 00 |
+----------+----+               +-----+
| 0x10004  | 12 |  \leftarrow
  | esp |
+----------+----+               +-----+





+----------+----+
| 0x10000  | 00 |
+----------+----+
| 0x10001  | 00 |
+----------+----+               +-----+
| 0x10002  | 78 |  \leftarrow
  | esp |
                                +-----+
+----------+----+
| 0x10003  | 56 |
+----------+----+
| 0x10004  | 12 |
+----------+----+





+----------+----+
| 0x10000  | 00 |
+----------+----+
| 0x10001  | 00 |
+----------+----+
| 0x10002  | 00 |
+----------+----+
| 0x10003  | 00 |
+----------+----+               +-----+
| 0x10004  | 12 |  \leftarrow
  | esp |
+----------+----+               +-----+




  Automatic variables

Local variables are variables that exist within a scope. A scope
is delimited by a pair of braces: {..}. The most common scope to
define local variables is at function scope. However, scope can
be unnamed, and variables created inside an unnamed scope do not
exist outside of its scope and its inner scope.

Function scope:

  void foo() {

    int a;

    int b;

}

  a and b are variables local to the function foo.



Unnamed scope:

  int foo() {

    int i;



    {

        int a = 1;

        int b = 2;

        {

            return i = a + b;

        }

    }

}

  a and b are local to where it is defined and local into its
  inner child scope that return i = a + b. However, they do not
  exist at the function scope that creates i.

When a local variable is created, it is pushed on the stack; when
a local variable goes out of scope, it is pop out of the stack,
thus destroyed. When an argument is passed from a caller to a
callee, it is pushed on the stack; when a callee returns to the
caller, the arguments are popped out the stack. The local
variables and arguments are automatically allocated upon enter a
function and destroyed after exiting a function, that's why it's
called automatic variables.

A base frame pointer points to the start of the current function
frame, and is kept in ebp register. Whenever a function is
called, it is allocated with its own dedicated storage on stack,
called stack frame. A stack frame is where all local variables
and arguments of a function are placed on a stack[footnote:
Data and only data are exclusively allocated on stack for every
stack frame. No code resides here.
].

When a function needs a local variable or an argument, it uses
ebp to access a variable:

• All local variables are allocated after the ebp pointer. Thus,
  to access a local variable, a number is subtracted from ebp to
  reach the location of the variable.

• All arguments are allocated before ebp pointer. To access an
  argument, a number is added to ebp to reach the location of the
  argument.

• The ebp itself pointer points to the return address of its
  caller.




+--------------------------------------+---------------------------------------------------------------------------+
|           Previous Frame             |                               Current Frame                               |
+--------------------------------------+-----------------------------+----------+----------------------------------+
|         Function Arguments           |                             |   ebp    |         Local variables          |
+-----+-----+-----+-----------+--------+-----------------------------+----------+-----+-----+-----+-----------+----+
| A1  | A2  | A3  | ........  |  An    |       Return Address        | Old ebp  | L1  | L2  | L3  | ........  | Ln |
+-----+-----+-----+-----------+--------+-----------------------------+----------+-----+-----+-----+-----------+----+




A = Argument

L = Local Variable

Here is an example to make it more concrete:

  Source

  int add(int @|\color{red}\bfseries a|@, int
@|\color{green}\bfseries b|@) {

    int @|\color{blue}\bfseries i|@ = @|\color{red}\bfseries a|@
+ @|\color{green}\bfseries b|@;



    return i;

}

  Assembly

  080483db <add>:

  #include <stdint.h>

  int add(int a, int b) {

   80483db:       push   ebp

   80483dc:       mov    ebp,esp

   80483de:       sub    esp,0x10

      int i = a + b;

   80483e1:       mov    edx,DWORD PTR [ebp+0x8]

   80483e4:       mov    eax,DWORD PTR [ebp+0xc]

   80483e7:       add    eax,edx

   80483e9:       mov    DWORD PTR [ebp-0x4],eax

      return i;

   80483ec:       mov    eax,DWORD PTR [ebp-0x4]

  }

   80483ef:       leave

   80483f0:       ret

In the assembly listing, [ebp-0x4] is the local variable i, since
it is allocated after ebp, with the length of 4 bytes (an int).
On the other hand, a and b are arguments and can be accessed with
ebp:

• [ebp+0x8] accesses a.

• [ebp+0xc] access b.

For accessing arguments, the rule is that the closer a variable
on stack to ebp, the closer it is to a function name.




                       +-------------------+            +-------------------+            +-------------------+            +-------------------+
                       |      ebp+0xc      |            |      ebp+0x8      |            |      ebp+0x4      |            |        ebp        |
                       +-------------------+            +-------------------+            +-------------------+            +-------------------+
                                                                                                                                ---------------
                               \downarrow
                      \downarrow
                      \downarrow
                      \downarrow

+----------+-----+-----+-----+--------------+-----+-----+-----+--------------+-----+-----+-----+--------------+-----+-----+-----+-------------+
|          | 00  | 01  | 02  |     03       | 04  | 05  | 06  |     07       | 08  | 09  | 0a  |     0b       | 0c  | 0d  | 0e  |     0f      |
+----------+--------------------------------+--------------------------------+--------------------------------+-------------------------------+
| 0x10000  |               b                |               a                |        Return Address          |            Old ebp            |
+----------+--------------------------------+--------------------------------+--------------------------------+-------------------------------+

                                                                                         +-------------------+            +-------------------+
                                                                                         |      ebp+0x8      |            |      ebp+0x4      |
                                                                                         +-------------------+            +-------------------+
                                                                                                 \downarrow
                      \downarrow

+----------+-----+-----+-----+--------------+-----+-----+-----+--------------+-----+-----+-----+--------------+-----+-----+-----+-------------+
|          | 00  | 01  | 02  |     03       | 04  | 05  | 06  |     07       | 08  | 09  | 0a  |     0b       | 0c  | 0d  | 0e  |     0f      |
                                                                             +-----                           +-----            +-------------+
+----------+-----+-----+-----+--------------+-----+-----+-----+--------------+-----+-----+-----+--------------+-------------------------------+
|  0xffe0  |     |     |     |              |     |     |     |              |     |     |     |      N       |               i               |
+----------+-----+-----+-----+--------------+-----+-----+-----+--------------+-----+-----+-----+--------------+-------------------------------+




N = Next local variable starts here

From the figure, we can see that a and b are laid out in memory
with the exact order as written in C, relative to the return
address.

  Function Call and Return<sub:Function-Call-and>

  Source

  #include <stdio.h>



int add(int a, int b) {

    int local = 0x12345;



    return a + b;

}



int main(int argc, char *argv[]) {

    add(1,1);



    return 0;

}

  Assembly

  For every function call, gcc pushes arguments on the stack in
  reversed order with the push instructions. That is, the
  arguments pushed on stack are in reserved order as it is
  written in high level C code, to ensure the relative order
  between arguments, as seen in previous section how function
  arguments and local variables are laid out. Then, gcc generates
  a call instruction, which then implicitly pushes a return
  address before transferring the control to add function:

  080483f2 <main>:

  int main(int argc, char *argv[]) {

   80483f2:       push   ebp

   80483f3:       mov    ebp,esp

      add(1,2);

   80483f5:       push   0x2

   80483f7:       push   0x1

   80483f9:       call   80483db <add>

   80483fe:       add    esp,0x8

      return 0;

   8048401:       mov    eax,0x0

  }

   8048406:       leave

   8048407:       ret

Upon finishing the call to add function, the stack is restored by
adding 0x8 to stack pointer esp (which is equivalent to 2 pop
instructions). Finally, a leave instruction is executed and main
returns with a ret instruction. A ret instruction transfers the
program execution back to the caller to the instruction right
after the call instruction, the add instruction. The reason ret
can return to such location is that the return address implicitly
pushed by the call instruction, which is the address right after
the call instruction; whenever the CPU executes ret instruction,
it retrieves the return address that sits right after all the
arguments on the stack:

At the end of a function, gcc places a leave instruction to clean
up all spaces allocated for local variables and restore the frame
pointer to frame pointer of the caller.

080483db <add>:

#include <stdio.h>

int add(int a, int b) {

 80483db:       push   ebp

 80483dc:       mov    ebp,esp

 80483de:       sub    esp,0x10

    int local = 0x12345;

 80483e1:       DWORD PTR [ebp-0x4],0x12345

    return a + b;

 80483e8:       mov    edx,DWORD PTR [ebp+0x8]

 80483eb:       mov    eax,DWORD PTR [ebp+0xc]

 80483ee:       add    eax,edx

}

 80483f0:       leave

 80483f1:       ret

The above code that gcc generated for function calling is
actually the standard method x86 defined. Read chapter 6, “
Produce Calls, Interrupts, and Exceptions”, Intel manual volume
1.

  Loop

Loop is simply resetting the instruction pointer to an already
executed instruction and starting from there all over again. A
loop is just one application of jmp instruction. However, because
looping is a pervasive pattern, it earned its own syntax in C.

  Source

  #include <stdio.h>



int main(int argc, char *argv[]) {

    for (int i = 0; i < 10; i++) {

    }



    return 0;

}

  Assembly

  080483db <main>:

  #include <stdio.h>

  int main(int argc, char *argv[]) {

   80483db:       push   ebp

   80483dc:       mov    ebp,esp

   80483de:       sub    esp,0x10

      for (int i = 0; i < 10; i++) {

   80483e1:       mov    DWORD PTR [ebp-0x4],0x0

   80483e8:       jmp    80483ee <main+0x13>

   80483ea:       add    DWORD PTR [ebp-0x4],0x1

   80483ee:       cmp    DWORD PTR [ebp-0x4],0x9

   80483f2:       jle    80483ea <main+0xf>

      }

      return 0;

   80483f4: b8 00 00 00 00        mov    eax,0x0

  }

   80483f9: c9                    leave

   80483fa: c3                    ret

   80483fb: 66 90                 xchg   ax,ax

   80483fd: 66 90                 xchg   ax,ax

   80483ff: 90                    nop

  The colors mark corresponding high level code to assembly code:

  1. The red instruction initialize i to 0.

  2. The green instructions compare i to 10 by using jle and
    compare it to 9. If true, jump to 80483ea for another
    iteration.

  3. The blue instruction increase i by 1, making the loop able
    to terminate once the terminate condition is satisfied.

  Why does the increment instruction (the blue instruction)
  appears before the compare instructions (the green
  instructions)?

    What assembly code can be generated for while and do...while?

  Conditional

Again, conditional in C with if...else... construct is just
another application of jmp instruction under the hood. It is also
a pervasive pattern that earned its own syntax in C.

  Source

  #include <stdio.h>



int main(int argc, char *argv[]) {

    int i = 0;



    if (argc) {

        i = 1;

    } else {

        i = 0;

    }



    return 0;

}

  Assembly

  int main(int argc, char *argv[]) {

   80483db:        push   ebp

   80483dc:        mov    ebp,esp

   80483de:        sub    esp,0x10

      int i = 0;

   80483e1:        mov    DWORD PTR [ebp-0x4],0x0

      if (argc) {

   80483e8:        cmp    DWORD PTR [ebp+0x8],0x0

   80483ec:        je     80483f7 <main+0x1c>

          i = 1;

   80483ee:        mov    DWORD PTR [ebp-0x4],0x1

   80483f5:        jmp    80483fe <main+0x23>

      } else {

          i = 0;

   80483f7:        mov    DWORD PTR [ebp-0x4],0x0

      }

      return 0;

   80483fe:        mov    eax,0x0

  }

   8048403:        leave

   8048404:        ret

  The generated assembly code follows the same order as the
  corresponding high level syntax:

  • red instructions represents if branch.

  • blue instructions represents else branch.

  • green instruction is the exit point for both if and else
    branch.

  if branch first compares whether argc is false (equal to 0)
  with cmp instruction. If true, it proceeds to else branch at
  80483f7. Otherwise, if branch continues with the code of its
  branch, which is the next instruction at 80483ee for copying 1
  to i. Finally, it skips over else branch and proceeds to
  80483fe, which is the next instruction pasts the if..else...
  construct.

  else branch is entered when cmp instruction from if branch is
  true. else branch starts at 80483f7, which is the first
  instruction of else branch. The instruction copies 0 to i, and
  proceeds naturally to the next instruction pasts the
  if...else... construct without any jump.
